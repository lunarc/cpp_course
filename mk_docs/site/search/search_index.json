{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scientific Programming in C++","text":"<p>This course is intended as an introduction to C++ for engineers or researchers using the language to develop computational applications or workflows requiring a high-performance language. The target audience are existing users of Python, NumPy and Matplotlib. </p> <p>The course gives a thorough introduction to C++ covering both classic as well modern features of the language. The focus is on tools required to develop computational codes using established libraries for array computing (Eigen), user interface design (Qt) and visualization (VTK).</p> <p>The course focuses a lot on complete examples of code that are ready to run. In addition, the course documentation is complemented with a complete source code tree on GitHub with all of the examples described in the course. </p>"},{"location":"build_and_run/","title":"Building and running C++ code","text":"<p>To install and run C++, you will need a compiler. There are several compilers available for C++ that work on all major platforms. For this course, we will be using the GNU C++ compiler. Along with the compiler, it is recommended to have a good text editor that has support for C++. To further simplify the process of compiling, running, and debugging C++ code, a development environment is recommended. In this course, we will use Qt Creator, which is an advanced environment specifically designed for C++. It provides features such as building, debugging, and running both command line and graphical applications using Qt.</p> <p>As we are not going to develop commercial code in this course we can download and use the open source version of Qt Creator, which can be downloaded from the following URL:</p> <p>Download open source Qt Creator</p>"},{"location":"build_and_run/#installing-qt-creator-and-c-compiler-windows","title":"Installing Qt Creator and C++ compiler (Windows)","text":"<p>Download and run the online installer from the URL above. To use the installer you need to create an Qt account. When this has been done, enter your account information into the following dialog box and click Next.</p> <p></p> <p>Check the box that you agree to the GPL license requirements. Click Next.</p> <p></p> <p>In the Select components section make sure to select:</p> <ul> <li>Qt 6.5.x</li> <li>Qt Creator 10.0.2</li> <li>Qt Creator 10.0.2 CDB Debugger support</li> <li>Debugging support for Windows</li> <li>MinGW 11.2.0 64-bit</li> </ul> <p>Click Next.</p> <p></p> <p>Continue the dialog to complete the installation of Qt Creator on Windows. When completed you should now have the development environment Qt Creator and the GCC 11.2 compilers for C++ available. Qt Creator is now available in the start menu.</p>"},{"location":"build_and_run/#installing-qt-creator-and-c-compiler-linux","title":"Installing Qt Creator and C++ compiler (Linux)","text":"<p>On Linux Qt Creator will use any installed compilers on the system, so make sure you have installed these before running the installer. This can be done using the following commands on an Ubuntu system:</p> <pre><code>sudo apt-get install build-essential\n</code></pre> <p>On Linux you also download the online installer using the previous link. The installer comes in the form of an executable script, which you need to run. To do this open a terminal and do the following commands on the downloaded file:</p> <pre><code>chmod +x qt-unified-linux-x64-4.6.0-online.run\n./qt-unified-linux-x64-4.6.0-online.run\n</code></pre> <p>The installer works just as for the Windows version. Select the following options in the Select components page in the installer:</p> <p></p> <p>If you want Qt Creator to be available you will need to add the following to the system path in Linux:</p> <pre><code>export PATH=$HOME/Qt/[qt version]/gcc_64/bin:$HOME/Qt/Tools/QtCreator/bin:$PATH\n</code></pre> <p>Add this file in your .bash_profile in your home directory. Replace [qt version] with the installed Qt version.</p>"},{"location":"build_and_run/#installing-qt-creator-and-c-compiler-macos","title":"Installing Qt Creator and C++ compiler (macOS)","text":"<p>TBD.</p>"},{"location":"build_and_run/#creating-a-c-project-in-qt-creator","title":"Creating a C++ project in Qt Creator","text":"<p>When you start Qt Creator for the first time the following window appears:</p> <p></p> <p>On the left side there are 6 main sections in the left toolbar. </p> <ul> <li>Welcome - Shows a start page for Qt Creator with shortcuts and example projects.</li> <li>Edit - Here you edit your files in your project. More on that in the following sections.</li> <li>Design - Used to edit user interfaces when a Qt user interface project is used.</li> <li>Debug - Debug mode used when debugging your project.</li> <li>Projects - Project configuration options.</li> <li>Help - Help on how to use Qt Creator.</li> </ul> <p>To create a new project in Qt Creator select File/New project... from the menu or press [Ctrl]+[Shift]+N. This brings up a wizard for creating a new project. </p> <p>First we need to select the project type. For the most part of this course we will only need a Plain C++ Application project. See below:</p> <p></p> <p>In the next page we need to specify the name and location of the new project.</p> <p></p> <p>Now we need to specify the build system used by this project. The choices are CMake and QMake. In this course we will focus on CMake for our projects, so keep the default choice.</p> <p></p> <p>In this step the compiler kit needs to be selected. If all goes well it should show a valid configuration. In the image below the MinGW compiler kit for Windows is preselected.</p> <p></p> <p>If you want to use version control this can be specified in the following step.</p> <p></p> <p>When the guide is completed we should end up with the following window in Qt Creator. The Projects pane will show the files in your project and the editor will show you the main application source file, main.cpp.</p> <p></p>"},{"location":"build_and_run/#building-your-application","title":"Building your application","text":"<p>To build the application select Build/Build Project \"MyAppliction from the menu or click on the build button in the lower left toolbar:</p> <p></p> <p>Output from the build can be shown by clicking the 4 Compile output button in the lower part of the window. This brings up the log of the compiler output.</p> <p></p> <p>Any issues can also be shown by opening the issues pane using the 1 Issues button in the lower part of the window.</p> <p></p> <p>Double clicking a row in the issues pane will bring you to the corresponding line in the source code.</p>"},{"location":"build_and_run/#running-your-application","title":"Running your application","text":"<p>Running your application in Qt Creator can be done using the play button in the lower left toolbar.</p> <p></p> <p>If your code has not been built it will be built before it is run. Output from your application is shown in the 3 Application output pane in the lower part of the window.-</p> <p></p>"},{"location":"build_and_run/#adding-source-files-to-your-project","title":"Adding source files to your project","text":"<p>Adding files to your project is a 2 step process. First we create the files and save them in the project source directory. Select File/New file... in the menu. In the guide that comes up select a General/Empty file. </p> <p></p> <p>Save it as a file called myfunc.h in the project source directory. In the next step just click Finish. Qt Creator currently can't add files automatically to the CMakeLists.txt file, and it shows the following dialogue,</p> <p></p> <p>asking you if it should copy the filename to the clipboard. Answer Yes.</p> <p>Next open the CMakeLists.txt file and add myfunc.h to the the add_executable(...) statement:</p> <pre><code>cmake_minimum_required(VERSION 3.5)\n\nproject(MyApplication LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nadd_executable(MyApplication myfunc.h main.cpp)\n\ninstall(TARGETS MyApplication\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n)\n</code></pre> <p>Same procedure can be done to add a myfunc.cpp file. The final CMakeLists.txt should look like:</p> <pre><code>cmake_minimum_required(VERSION 3.5)\n\nproject(MyApplication LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nadd_executable(MyApplication myfunc.h myfunc.cpp main.cpp)\n\ninstall(TARGETS MyApplication\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n)\n</code></pre>"},{"location":"build_and_run/#building-on-the-command-line","title":"Building on the command line","text":"<p>Building a C++ application from the command line can be done using the following commands:</p> <pre><code>$ g++ myfunc.h myfunc.cpp main.cpp -o myapp\n</code></pre> <p>This will compile and link the source files myfunc.h, myfunc.cpp and main.cpp, producing an executable myapp.</p>"},{"location":"build_and_run/#running-on-the-command-line","title":"Running on the command line","text":"<p>Running the compiler executable on the command line can be done using the following command:</p> <pre><code>$ ./myapp\nHello World!\n</code></pre>"},{"location":"code_org/","title":"Organising your code","text":"<ul> <li>C++ does not have any concept of modules of code</li> <li>Compiler \u201csees\u201d only one single block of text</li> <li>Preprocessor handles code structuring</li> <li><code>#include</code> directive includes external source files for consideration when compiling</li> <li>Header files \u2013 Files containing function prototypes for used libraries</li> <li><code>#include &lt;filename&gt;</code> include file in standard locations</li> <li><code>#include \"filename\"</code> include file relative to compiled source code</li> </ul>"},{"location":"code_org/#the-c-compilation-and-linking","title":"The C++ compilation and linking","text":"<ol> <li>Source files are combined with header files to source units.</li> <li>The compiler compiles each source unit to an object file.</li> <li>Object files are linked together to form applications or shared libraries by the linker.</li> </ol>"},{"location":"code_org/#code-module-in-c","title":"Code module in C++","text":"<ul> <li>A module in C++ is usually defined by a </li> <li>header file (.h)</li> <li>source file (.cpp)</li> <li>Header file contains functions and class definitions</li> <li>Source file contains the actual functions</li> <li>Problem: How do you handle headers used in multiple source files \u2013 duplicate function prototypes</li> </ul>"},{"location":"code_org/#headers-and-source-files","title":"Headers and source files","text":"Using header guardsUsing pragma once <p>Header file - array_utils.h</p> <pre><code>#ifndef __array_utils_h__\n#define __array_utils_h__\n\nint** createArray(int rows, int cols);\nvoid zeroArray(int**&amp; array, int rows, int cols);\nvoid deleteArray(int**&amp; array);\n\n#endif\n</code></pre> <p>Source file - header_files.cpp</p> <pre><code>#include &lt;iostream&gt;\n\n#include \"array_utils.h\"\n\nusing namespace std;\n\nint main()\n{\n    int** array;\n\n    array = createArray(4, 8);\n    zeroArray(array, 4, 8);\n\n    for (int i=0; i&lt;4; i++)\n    {\n        for (int j=0; j&lt;8; j++)\n            cout &lt;&lt; array[i][j] &lt;&lt; \", \";\n\n        cout &lt;&lt; endl;\n    }\n\n    deleteArray(array);\n}\n</code></pre> <p>Header file - array_utils2.h</p> <pre><code>#pragma once\n\nint** createArray(int rows, int cols);\nvoid zeroArray(int**&amp; array, int rows, int cols);\nvoid deleteArray(int**&amp; array);\n</code></pre> <p>Source file - header_files2.cpp</p> <pre><code>#include &lt;iostream&gt;\n\n#include \"array_utils2.h\"\n\nusing namespace std;\n\nint main()\n{\n    int** array;\n\n    array = createArray(4, 8);\n    zeroArray(array, 4, 8);\n\n    for (int i=0; i&lt;4; i++)\n    {\n        for (int j=0; j&lt;8; j++)\n            cout &lt;&lt; array[i][j] &lt;&lt; \", \";\n\n        cout &lt;&lt; endl;\n    }\n\n    deleteArray(array);\n}\n</code></pre>"},{"location":"code_org/#pragma-once","title":"pragma once","text":"<ul> <li>non-standard widely supported preprocessor directive</li> <li>Can be used to replace header guards</li> <li>Less code</li> <li>avoids name clashes</li> <li>improved compile speed</li> </ul>"},{"location":"data_structures_algorithms/","title":"Data structures and algorithms","text":"<p>The C++ standard library contains many common data structures that are useful when implementing your application. Most of the data structures defined only support various basic functionality, instead algorithmic functionality is instead implemented separately and can work mostly with any data structures. Data structures are not type-specific and are implemented as template classes, supporting all builtin and user-defined data types.</p> <p>The most common data structures in C++ are divided into the following different types:</p> <ul> <li>Array type structures (T is the data type)<ul> <li>std::vector&lt;T&gt;</li> <li>std::array&lt;T&gt;</li> <li>std::deque&lt;T&gt;</li> </ul> </li> <li>Linked list structures<ul> <li>std::list&lt;T&gt;</li> </ul> </li> <li>Stacks and queues<ul> <li>std::stack&lt;T&gt;</li> <li>std::queue&lt;T&gt;</li> </ul> </li> <li>Associative containers<ul> <li>std::map&lt;Key, T&gt;</li> <li>std::multimap&lt;Key, T&gt;</li> <li>std::set&lt;Key&gt;</li> <li>std::multiset&lt;Key&gt;</li> </ul> </li> </ul>"},{"location":"data_structures_algorithms/#data-structures-and-iterators","title":"Data structures and iterators","text":"<p>To access and move through data structures C++ uses the concepts of an iterator. An iterator is a special type unique for each data structure that provides a way of moving through the elements in the data structure. It can be compared to the C++ pointer type, but with additional functionality. The value located where the iterator is positioned is accessed by dereferencing the iterator using the star operator (*).</p> <p>Depending on the data structure the iterator can belong to different categories:</p> <ul> <li>InputIterator - Can read and move forward. Only supports a single pass through the data structure.</li> <li>ForwardIterator - Can read, move forward supporting multiple passes.</li> <li>BidirectionalIterator - Can read, move forward and backwards.</li> <li>RandomAccessIterator - An iterator can access any element in any order.</li> <li>OutputIterator - Any of the above that support writing is considered a mutable iterator.</li> </ul> <p>To get a starting point for an iterator all data structures have a .begin() and .end() method. .begin() returns an iterator at the beginning of the data structure. .end() returns an iterator after the last item in the data structure. .end() is useful to be able to stop an iteration through a data structure, comparing the current iterator to the .end()-iterator. </p> <p>To illustrate the use of iterators we use the std::vector&lt;T&gt; as an example. std::vector is a data structure for storing values in a dynamically resizable array. First we declare and initialise the data structure.</p> <pre><code>std::vector&lt;int&gt; v = { 1, 2, 3, 4, 5, 6 };\n</code></pre> <p>This initializes the vector with some values. In the next step, we need to declare an iterator so that we can loop through the vector.</p> <pre><code>std::vector&lt;int&gt;::iterator it;\n</code></pre> <p>Now we have all information to be able to iterate over the vector. To do this we use a standard loop statement. At the start of the loop, we initialize the iterator to the start iterator of the vector. We loop until it encounters the end iterator of the vector. For each iterator, we also need to move the iterator forward in the data structure using the ++ operator.</p> <pre><code>for (it=v.begin; it!=v.end(); it++)\n</code></pre> <p>To access the actual value that corresponds to the current position of the iterator we can use the star operator (*).</p> <pre><code>    cout &lt;&lt; *it &lt;&lt; \"\\n\";\n</code></pre> <p> Try example</p> <p>If the data structure supports random access to the individual elements it is also possible to access the individual elements using the []-operator or the .at()-method. The .at()-method also supports bound checking.</p> <pre><code>cout &lt;&lt; v[0] &lt;&lt; \"\\n\";    // random acces to element 0 without bounds check.\ncout &lt;&lt; v.at(1) &lt;&lt; \"\\n\"; // radnom access to element 1 with bounds check.\n</code></pre> <p>We can simplify the code a bit using some of the more modern features of C++. First we don't have to specify the type of the vector if the element type can be deduced from the intialisation list.</p> <pre><code>std::vector v = { 1, 2, 3, 4, 5 };\n</code></pre> <p>We also don't have to explicitly declare an iterator before the for-statement. The auto-keyword can be used as the iterator type can be deduced by the compiler.</p> <pre><code>for (auto it=v.begin(); it!=v.end(); it++)\n{\n    cout &lt;&lt; *it &lt;&lt; \"\\n\";\n}\n</code></pre> <p> Try example</p>"},{"location":"data_structures_algorithms/#range-based-loops","title":"Range-based loops","text":"<p>To make it even easier iterate over data structure a new loop construct was introduced to the C++ language, the range-based loop. This construct is very similar to the way you iterate over data structures in Python. The syntax is simplifed:</p> <pre><code>for (named-variable : range-expression)\n    loop-body\n</code></pre> <p>The name-variable is a variable of the same type as declared in the data structure to loop over. range-expression is the data structure that we will iterate over. A simple example iterating over a vector.</p> <p><pre><code>std::vector vec = { 1, 2, 3, 4, 5 };\n\nfor (auto value : vec)\n    std::cout &lt;&lt; value &lt;&lt; \"\\n\";\n</code></pre>  Try example</p> <p>As we can see in the above example there is no need to use any iterators. In the following example value is copied from vec. If you have larger values in your data structures it is not efficient to copy the value in each iteration. To solve this the range-based loop can also be implemented using the reference operator (&amp;). The code then becomes:</p> <pre><code>std::vector vec = { 1, 2, 3, 4, 5 };\n\nfor (auto&amp; value : vec)\n    std::cout &lt;&lt; value &lt;&lt; \"\\n\";\n</code></pre> <p> Try example</p> <p>In this implementation value is actually a reference to the value in vec. It is also possible to change the actual values of vec by assigning a value to value.</p> <p><pre><code>std::vector vec = { 1, 2, 3, 4, 5 };\n\nfor (auto&amp; value : vec)\n    value = 0;\n\nfor (auto&amp; value : vec)\n    cout &lt;&lt; value &lt;&lt; \"\\n\";\n</code></pre>  Try example</p> <p>Note</p> <p>To be able to use the range-based for loop in C++ the data structure that you iterate over need to support iterators as this is the inner mechanics for the range-base loop.</p>"},{"location":"data_structures_algorithms/#stdarrayt-n","title":"std::array&lt;T, N&gt;","text":"<p>If the size of an array is known at compile time, it is often more effective to use a static array. However, the static C-based array in C++ is often harder to use with built-in algorithms and range-based loops as it lacks an easy way of querying the size of the array. To overcome this the std::array was introduced. This data structure combines the benefits of a C based static array with standard C++ container based data structure. To use the array we use the following include:</p> <pre><code>#include &lt;array&gt;\n</code></pre> <p>To declare a std::array you have to specify a data type and the size of the array:</p> <pre><code>std::array&lt;float, 10&gt; arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n</code></pre> <p>As this data structure is compatible with standard C++ containers it is possible to use a range-based for loop to iterate over the values.</p> <pre><code>for (auto&amp; value : arr)\n    cout &lt;&lt; value &lt;&lt; \"\\n\";\n</code></pre> <p>It is also possible to use C++ type deduction to automatically create an array without specifying data type and size.</p> <pre><code>std::array arr = { 1.0f, 2.0f, 3.0f, 4.0f , 5.0f , 6.0f, 7.0f, 8.0f, 9.0f, 10.0f };\n</code></pre> <p>The size of an array can be queried using the .size() method.</p> <p><pre><code>cout &lt;&lt; \"array size = \" &lt;&lt; arr.size() &lt;&lt; \"\\n\";\n</code></pre>  Try example</p> <p>std::array can also be used exactly as a normal array using the []-operator.</p> <p><pre><code>for (auto i=0; i&lt;arr.size(); i++)\n    cout &lt;&lt; arr[i] &lt;&lt; \"\\n\";\n</code></pre>  Try example</p> <p>Consider using std::array instead of static arrays whenever possible. If a pointer to an array is required it is always possible to use the .data() to get access to the pointer of the underlying array.</p> <pre><code>auto* parr = arr.data();\n\nfor (auto i=0; i&lt;10; i++)\n    cout &lt;&lt; parr[i] &lt;&lt; \"\\n\";\n</code></pre> <p> Try example</p> <p>Another nice feature of the std::array is that you can use it with range-based loops as shown in the following example:</p> <pre><code>for (auto &amp;v : arr)\n    std::cout &lt;&lt; v &lt;&lt; \"\\n\";\n</code></pre> <p>Using range-based loops with arrays prevents errors where you access your arrays outside their defined range (bound checking errors).</p> <p> Try example</p>"},{"location":"data_structures_algorithms/#stdvector","title":"std::vector <p>std::vector is a linear data structure that can expand when a certain capacity is reached. It is very similar to the std::array data structure, but the size is not fixed. The data structure can be accessed with iterators as well as direct access using the []-operator. Elements can be added by using the method .push_back(). The efficiency of the the different operations are as follows:</p> <ul> <li>Directly accessing elements can be done in constant time - O(1).</li> <li>Adding or removing element can be done in amortized constant time O(1). That is on average the operation can be completed in O(1) complexity.</li> <li>Inserting or removing elements at a specific position can be done in O(n) operations.</li> </ul> <p>Below is an example of an explicit declaration of a std::vector.</p> <pre><code>std::vector&lt;int&gt; vec = { 1, 2, 3, 4, 5 };\n</code></pre> <p>It is also possible to skip the data type and let the compiler decide using deduction.</p> <pre><code>std::vector vec = { 1, 2, 3, 4, 5 };\n</code></pre> <p>Elements can be added using the .push_back() method.</p> <pre><code>vec.push_back(6);\nvec.push_back(7);\n</code></pre> <p>A new method was added in C++11, .emplace_back(), which can be used if a new non-existent object should be added to the vector. This method avoids unnecessary copying that could occur otherwise. For the built-in data types, this difference is negligible, but for more complex data types this can improve performance significantly.</p> <p>The size of the array can be queried using the .size() method.</p> <pre><code>std::cout &lt;&lt; vec.size() \"\\n\";\n</code></pre> <p>We can iterate over the vector using both iterators and direct access loops. Iterating using a loop variable.</p> <pre><code>for (auto i=0; i&lt;vec.size(); i++)\n    std::cout &lt;&lt; vec[i] &lt;&lt; \", \";\n\nstd::cout &lt;&lt; \"\\n\";\n</code></pre> <p>Iterating using iterator is shown below:</p> <pre><code>for (auto it=vec.begin(); it!=vec.end(); it++)\n    std::cout &lt;&lt; *it &lt;&lt; \", \";\n\nstd::cout &lt;&lt; \"\\n\";\n</code></pre> <p>Finally, we can use a range-based for-loop as well:</p> <pre><code>for (auto&amp; v : vec)\n    std::cout &lt;&lt; v &lt;&lt; \", \";\n\nstd::cout &lt;&lt;\"\\n\";\n</code></pre> <p> Try example</p> <p>Removing items from a vector can be done using the .erase() method, which takes an iterator as argument. The following code erases the first element:</p> <pre><code>vec.erase(vec.begin());\n</code></pre> <p>In many cases you want to erase a specific element at a specific index. This can be done by adding an index value to an iterator as in this code which erases the second element.</p> <pre><code>vec.erase(vec.begin()+1);\n</code></pre> <p>It is also possible to insert elements using the .insert() method. This methods takes an iterator as an argument for the position where the value should be inserted and the value that should be inserted. The following code inserts 42 at the third position in the list</p> <pre><code>vec.insert(vec.begin()+2, 42);\n</code></pre> <p>The size of the vector can be changed using the .resize() method. If the new size is larger than the current size elements are added to the vector. If the new size is smaller existing elements will be erased.</p> <p>A std::vector is not resized on all calls to .push_back(), usually the capacity is doubled every time capacity is exceeded. The current number of allocated elements in a vector can be queried using the .capacity() method. This value is often larger than .size(). </p> <p>If you know that a vector should be at least a certain number of elements it is possible to pre-allocate the number of elements using the .reserve() method. Note that this method does not change the size of the vector. There is also a special method for freeing up unused memory .shrink_to_fit() in the vector. </p> <p>The following figure illustrates how the std::vector works:</p>   std::vector data structure  <p>All elements in a std::vector can be cleared using the .clear() method.  </p> <pre><code>vec.clear();\n</code></pre> <p>A more complete example is shown below:</p> ExampleOutput   <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n\nint main()\n{\n    srand((unsigned)time(0));\n\n    std::vector&lt;int&gt; vec;\n\n    for (auto i=0; i&lt;10; i++)\n        vec.emplace_back(rand());\n\n    for (size_t i=0; i&lt;vec.size(); i++)\n        std::cout &lt;&lt; vec[i] &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt; \"\\n\";\n\n    for (auto it=vec.begin(); it!=vec.end(); it++)\n        std::cout &lt;&lt; *it &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt; \"\\n\";\n\n    for (auto&amp; v : vec)\n        v = rand();\n\n    for (auto&amp; v : vec)\n        std::cout &lt;&lt; v &lt;&lt; \"\\n\";\n}\n</code></pre>   <pre><code>12637\n6149\n30314\n32595\n9916\n7874\n3554\n5407\n13053\n27214\n\n12637\n6149\n30314\n32595\n9916\n7874\n3554\n5407\n13053\n27214\n\n20108\n3184\n14168\n23442\n18432\n24466\n2492\n25169\n5702\n14458\n</code></pre>    <p> Try example</p> <p> More info on std::vector (cppreference)</p>","text":""},{"location":"data_structures_algorithms/#stddeque","title":"std::deque <p>std::deque is similar to std::vector, linearly ordered, but supports efficiently adding and removing elements at the beginning and end. Compared to the std::vector no guarantees are given that the allocated data structure is contiguous. The advantage is that this data structure avoids large reallocations. </p> <p>The efficiency of the the different operations are as follows:</p> <ul> <li>Directly accessing elements can be done in constant time - O(1).</li> <li>Adding and removing elements at the beginning or end is achieved in constant time - O(1).</li> <li>Inserting or removing elements at a specific position can be done in linear O(n) operations.</li> </ul> <p>The conceptual data structure of std::dequeue is shown in the following figure:</p>   std::deque data structure  <p>std::deque adds some additional methods for adding and removing items at the front and back of the datastructure:</p> <ul> <li>.push_back(...) - Adds an item at the end.</li> <li>.pop_back(...) - Removes an item from the end.</li> <li>.push_front(...) - Adds an item at the front.</li> <li>.push_front(...) - Remove an item at the front.</li> </ul> <p>It is also possible to access the front and back elements using the methods .front() and .back(). Removing elements from the front and back can be done using the .pop_front() and .pop_back(). It is also possible to access element directly as in std::vector using the []-operator and the .as()-method.</p> <p>An example of how this is used is shown in the following code:</p> ExampleOutput   <pre><code>#include &lt;deque&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    deque&lt;int&gt; q;\n\n    // Add items to the back\n\n    for (auto i = 0; i &lt; 5; i++)\n        q.push_back(i);\n\n    // Add items to the front\n\n    for (auto i = 5; i &lt; 10; i++)\n        q.push_front(i);\n\n    // Iterate using iterators\n\n    for (auto it = q.begin(); it != q.end(); it++)\n        cout &lt;&lt; *it &lt;&lt; \", \";\n\n    cout &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"\\n\";\n\n    // Iterate using range-based loop\n\n    for (auto &amp;i : q)\n        cout &lt;&lt; i &lt;&lt; \", \";\n\n    cout &lt;&lt; \"\\n\";\n\n    // Popping and popping\n\n    cout &lt;&lt; \"q front = \" &lt;&lt; q.front() &lt;&lt; endl;\n    cout &lt;&lt; \"pop front\" &lt;&lt; endl;\n    q.pop_front();\n    cout &lt;&lt; \"q front = \" &lt;&lt; q.front() &lt;&lt; endl;\n    cout &lt;&lt; \"q back = \" &lt;&lt; q.back() &lt;&lt; endl;\n    cout &lt;&lt; \"pop back\" &lt;&lt; endl;\n    q.pop_back();\n    cout &lt;&lt; \"q back = \" &lt;&lt; q.back() &lt;&lt; endl;\n    cout &lt;&lt; \"q[3] = \" &lt;&lt; q[3] &lt;&lt; endl;\n}\n</code></pre>   <pre><code>9, 8, 7, 6, 5, 0, 1, 2, 3, 4, \n\n9, 8, 7, 6, 5, 0, 1, 2, 3, 4, \nq front = 9\npop front\nq front = 8\nq back = 4\npop back\nq back = 3\nq[3] = 5\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#stdlist","title":"std::list <p>std::list is a linearly ordered data structure, implemented as a linked list. The data structure is especially efficient at adding and removing elements in the middle of the sequence. The disadvantage of std::list is that there is no direct access to elements. You will need to iterate through to access all elements. The data structure is well-suited for sorting algorithms. The conceptual data structure is shown in the figure below:</p>   std::list data structure  <p>Just as for the std::deque we have the following methods for adding items to the list:</p> <ul> <li>.push_back(...) - Adds an item at the end.</li> <li>.pop_back(...) - Removes an item from the end.</li> <li>.push_front(...) - Adds an item at the front.</li> <li>.push_front(...) - Remove an item at the front.</li> </ul> <p>However, we don't have any []-operator or .at() method as this data structure does not allow direct access to its members. </p> <p>It is possible to add items to the list using the .insert() method. However, this requires an iterator position. We can iterate and insert at a certain position. Insert at the beginning is easy:</p> <pre><code>l.insert(l.begin(), 42);\n</code></pre> <p>Insert at a certain position in this case before the value is 9.</p> <pre><code>for (auto it = l.begin(); it != l.end(); it++)\n{\n    if (*it == 9)\n        l.insert(it, 43); \n}\n</code></pre> <p>To remove items in the list we need to use an algorithm or use any of the class methods .erase(), .remove() or .remove_if(). </p> <p>Specific values in a list can be removed using the .remove() method:</p> <pre><code>l.remove(5); // removes all elements with the value 5\n</code></pre> <p>Removing a specific element in the list is again done by iteration. Here we must be careful with the iterator so that we don't lose track of where to continue iteration. In the following example we delete all values that are equal to 3. We use the .erase() method to remove the iterator from the list, which moves and returns the iterator following the removed item. If the condition is not fulfilled we just move the iterator forward (++it). </p> <pre><code>for (auto it = l.begin(); it != l.end();)\n{\n    if (*it == 3)\n        it = l.erase(it); // Returns next iterator after erase.\n    else\n        ++it;\n}\n</code></pre>  <p>Note</p> <p>Please note that we don't move the iterator forward in the for-statement to handle the situation when we remove the item from the list using the .erase() method.</p>  <p>A complete example of using the std::list is shown below:</p> ExampleOutput   <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nvoid print_items(const auto &amp;list)\n{\n    for (auto &amp;v : list)\n        std::cout &lt;&lt; v &lt;&lt; \", \";\n    std::cout &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    std::list&lt;int&gt; l;\n\n    // Adding items to the list\n\n    for (auto i = 0; i &lt;= 5; i++)\n        l.push_back(i);\n\n    for (auto i = 6; i &lt;= 10; i++)\n        l.push_front(i);\n\n    l.insert(l.begin(), 42);\n\n    for (auto it = l.begin(); it != l.end(); it++)\n    {\n        if (*it == 9)\n            l.insert(it, 43);\n    }\n\n    // List iteration using iterators\n\n    for (auto it = l.begin(); it != l.end(); it++)\n        std::cout &lt;&lt; *it &lt;&lt; \", \";\n\n    std::cout &lt;&lt; \"\\n\";\n\n    // Range based iteration\n\n    for (auto &amp;v : l)\n        std::cout &lt;&lt; v &lt;&lt; \", \";\n\n    std::cout &lt;&lt; \"\\n\";\n\n    // Removing items from the front and back\n\n    std::cout &lt;&lt; \"l front = \" &lt;&lt; l.front() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"pop front\"\n              &lt;&lt; \"\\n\";\n\n    l.pop_front();\n\n    std::cout &lt;&lt; \"l front = \" &lt;&lt; l.front() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"l back = \" &lt;&lt; l.back() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"pop back\"\n              &lt;&lt; \"\\n\";\n\n    l.pop_back();\n\n    std::cout &lt;&lt; \"l back = \" &lt;&lt; l.back() &lt;&lt; \"\\n\";\n\n    print_items(l);\n\n    // Removing items using .remove()\n\n    l.remove(0);\n\n    print_items(l);\n\n    // Removing items using .erase()\n\n    for (auto it = l.begin(); it != l.end();)\n    {\n        if (*it == 3)\n            it = l.erase(it); // Returns next iterator after erase.\n        else\n            ++it;\n    }\n\n    print_items(l);\n}\n</code></pre>   <pre><code>42, 10, 43, 9, 8, 7, 6, 0, 1, 2, 3, 4, 5, \n42, 10, 43, 9, 8, 7, 6, 0, 1, 2, 3, 4, 5, \nl front = 42\npop front\nl front = 10\nl back = 5\npop back\nl back = 4\n10, 43, 9, 8, 7, 6, 0, 1, 2, 3, 4, \n10, 43, 9, 8, 7, 6, 1, 2, 3, 4, \n10, 43, 9, 8, 7, 6, 1, 2, 4, \n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#stdmap","title":"std::map <p>In many applications it is desirable to store data associated with a key. The key can for example be a phone number or a name. Using the key it is possible to quickly access the data associated with the key. The std::map data structure stores unique keys with a single value per key. </p> <p>To declare a std::map datatyep you have to specify 2 data types one for the key and a second one for the value. In the following code we specify a map, m, with a string key and an integer value type.</p> <pre><code>std::map&lt;std::string, int&gt; m;\n</code></pre> <p>Adding values to a map can be done by specifying a key using the []-operator and assigning a new value as shown below:</p> <pre><code>m[\"bob\"] = 42;\nm[\"alice\"] = 40;\nm[\"mike\"] = 30;\nm[\"richard\"] = 25;\n</code></pre> <p>If you assign to an already existing key the value is overwritten. It is also possible to use the .insert() method to insert values into the map:</p> <pre><code>m.insert({\"john\", 84});\n</code></pre> <p>It is also possible to insert multiple entries using .insert()</p> <pre><code>m.insert({\"caroline\", 94}, {\"eva\", 36});\n</code></pre> <p>One of the powerful aspect of a dictionary is the ability to quickly check for the existence of a key in a dictionary. std::map provides a method, .find(), that can query for a key. If a key is found an iterator is returned positioned at the key. If no key was found the method returns .end() iterator of the data structure. An example of this is shown below:</p> <pre><code>it = m.find(\"carl\");\n\nif (it != m.end())\n    std::cout &lt;&lt; \"found: \" &lt;&lt; it-&gt;first &lt;&lt; \", \" &lt;&lt; it-&gt;second &lt;&lt; \"\\n\";\nelse\n    std::cout &lt;&lt; \"Could not find Carl.\" &lt;&lt; std::endl;\n</code></pre> <p>I the example above you can also see how you access the key and value of an iterator using the -&gt;first and -&gt;second accessors. </p> <p>In the same way as the other data structures iteration over the elements can be done using iterators. As shown in the following code:</p> <pre><code>for (auto it = m.begin(); it != m.end(); it++)\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \", \" &lt;&lt; it-&gt;second &lt;&lt; \"\\n\";\n</code></pre> <p>Using the new modern features of C++ we can also use the range based for-loop to iterate over the std::map. In the following example we use a single loop variable to access the key and values in the data structure.</p> <pre><code>for (auto &amp;item : m)\n    std::cout &lt;&lt; item.first &lt;&lt; \", \" &lt;&lt; item.second &lt;&lt; \"\\n\"\n</code></pre> <p>Please note that now can use the dot-operator to access the first and second fields of the item variable. </p> <p>It is also possible to assign loop-variables for both the key as well as the value in a range-based loop.</p> <pre><code>for (auto &amp;[key, value] : m)\n    std::cout &lt;&lt; key &lt;&lt; \", \" &lt;&lt; value &lt;&lt; \"\\n\";\n</code></pre> <p>This almost looks line the range-based loop in Python.</p>","text":""},{"location":"data_structures_algorithms/#algorithms","title":"Algorithms <p>Up until now, we have covered some of the data structures available in the C++ standard library. These classes contain methods for moving through the structure in different ways. However, they don't provide any algorithms for searching or querying the data structures. In C++ there is a distinct separation between data structures and algorithms. This gives you the freedom to use any algorithm on any data structure. Algorithms in C++ are provided through &lt;algorithm&gt; header. The functions in this library can work with any data structure that provides .first and .last attributes.</p>","text":""},{"location":"data_structures_algorithms/#lambda-functions","title":"Lambda functions <p>Many of the algorithms provided in the standard library require a function to be provided for customising the behavior. To be able to use them you need to implement a function in C++ for each time you need to use the algorithm, which can be a bit complicated. To solve this problem C++ 11 introduced the concept of lambda functions. A lambda function is an anonymous function declaration that can be directly passed to a function call, without having to declare a named function in your source code. The simplified syntax is as follows:</p>  <p>[capture clause] (parameters) -&gt; return type { body }</p>  <p>The capture clause describes how the lambda functions should interact with variables outside the lambda function. By default, no interaction is specified. If an empty capture close is given, the lambda function can't interact with any variables. If an equal sign [=] is given the lambda function can access all variables by value. If [&amp;] is given all variables are passed by reference to the lambda function. Specific variables can be specified by name or by value using the normal conventions in C++. The parameters section defines the input arguments of a function. This works just like a normal function declaration in C++. The return type is an optional part that can be left out, but it can be specified to make it more explicit what the function returns. The last part of the lambda function is the actual function body that implements the function. </p> <p>A lambda function can be passed directly to a function or declared directly in the code. In the following example, a lambda function f is declared using the auto directive. The lambda function can then be called just like any other function:</p> <pre><code>auto f = [](int x) { return x * x; };\nstd::cout &lt;&lt; f(5) &lt;&lt; std::endl;\n</code></pre> <p>The function in this example takes int x as input and returns and int. The function can also be specified with a return type as shown in the following example:</p> <pre><code>auto f = [](int x) -&gt; int { return x * x; };\nstd::cout &lt;&lt; f(5) &lt;&lt; std::endl;\n</code></pre> <p>In the next example, we declare a function g that has a capture clause [=], which enables the function to access all variables outside the lambda function by value.</p> <pre><code>int c = 42;\n\nauto g = [=](int x) { return x * x + c; };\nstd::cout &lt;&lt; g(5) &lt;&lt; std::endl;\n</code></pre> <p>Accessing variables by references is achieved similarly in the following example:</p> <pre><code>int c = 42;\n\nauto h = [&amp;](int x) { return x * x + c; };\nstd::cout &lt;&lt; h(5) &lt;&lt; std::endl;\n</code></pre> <p>If the lambda function should only access specific variables they can be specified in explicetly in the capture clause as in this example:</p> <pre><code>int c = 42;\n\nauto p = [&amp;c](int x) -&gt; int { return x * x + c; };\nstd::cout &lt;&lt; p(5) &lt;&lt; std::endl;\n</code></pre> <p>Here, the variable c is accessed by reference in the lambda function. </p> <p>Lambda functions in C++ are a very important concept that we will be using extensively in the following sections on algorithms. They provide a way of quickly providing additional functionality to the algorithms. </p>","text":""},{"location":"data_structures_algorithms/#sorting","title":"Sorting <p>Sorting is a very common operation on data structures. C++ provides the std::sort() function for sorting. The function takes an iterator for the starting position and an iterator for the end position. By default it sorts in ascending order compared with the less than operator (&lt;), but it is also possible to supply your own comparison function. It is in this scenario where lambda functions provide a quick and easy way of specifying a comparison function.</p> <p>In the following example, we use the std::sort() function in C++ to sort two arrays, providing our own comparison function as a named lambda function and as an anonymous function directly in the call to std::sort(). The requirement for comparison is a function that takes two input variables and returns true or false depending on the result of the comparison operation. Using this we can create our custom function that determines the sorting order of the algorithm.</p> ExampleOutput   <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid print_vector(auto v)\n{\n    for (auto&amp; item : v)\n        std::cout &lt;&lt; item &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n    std::vector v1 = { 6, 4, 7, 3, 9, 0, 1, 5 };\n    std::vector v2 = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\n    auto greater_func = [](int a, int b) -&gt; bool { return a &gt; b; };\n\n    std::sort(v1.begin(), v1.end(), greater_func);\n    std::sort(v2.begin(), v2.end(), [](int a, int b) -&gt; bool { return a &lt; b; });\n\n    print_vector(v1);\n    print_vector(v2);\n}\n</code></pre>   <pre><code>9 7 6 5 4 3 1 0\n0 1 3 4 5 6 7 9\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#functions-with-functions-as-arguments","title":"Functions with functions as arguments <p>As with the provided algorithms in C++, it is also possible to implement a function that takes a function as an argument. The classical way of doing this is to declare a function that passes a function pointer. </p> <pre><code>void tabulate_c(double x_start, double x_end, double dx, double (*f)(double))\n</code></pre> <p>In this example f is pointer to a function that takes a double as argument and returns a double value. If we have a declared function:</p> <pre><code>double q(double x)\n{\n    return cos(x);\n}\n</code></pre> <p>We can call the tabulate_c() function as follows:</p> <pre><code>tabulate_c(-6.0, 6.0, 0.2, q);\n</code></pre> <p>It is also possible to pass a lambda-function to this function:</p> <pre><code>tabulate_c(-6.0, 6.0, 0.2, [](double x) -&gt; double { return sin(x); });\n</code></pre> <p>The best way to declare a function argument is to use the std::function declaration. This provides a way to describe any kind of function call in C++ regardless of it being a lambda, function or function object. The previous function can then be declared as follows:</p> <pre><code>void tabulate(double x_start, double x_end, double dx, std::function&lt;double(double x)&gt; const&amp; f)\n</code></pre> <p>A complete example of this can be found in the following example:</p> ExampleOutput   <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;cmath&gt;\n\nvoid tabulate_c(double x_start, double x_end, double dx, double (*f)(double))\n{\n    auto x = x_start;\n\n    std::cout &lt;&lt; \"x, f(x)\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"-------------------\" &lt;&lt; std::endl;\n\n    while (x &lt;= x_end)\n    {\n        std::cout &lt;&lt; x &lt;&lt; \", \" &lt;&lt; f(x) &lt;&lt; std::endl;\n        x += dx;\n    }\n}\n\nvoid tabulate(double x_start, double x_end, double dx, std::function&lt;double(double x)&gt; const&amp; f)\n{\n    auto x = x_start;\n\n    std::cout &lt;&lt; \"x, f(x)\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"-------------------\" &lt;&lt; std::endl;\n\n    while (x &lt;= x_end)\n    {\n        std::cout &lt;&lt; x &lt;&lt; \", \" &lt;&lt; f(x) &lt;&lt; std::endl;\n        x += dx;\n    }\n}\n\ndouble q(double x)\n{\n    return cos(x);\n}\n\nint main()\n{\n    tabulate(-6.0, 6.0, 0.2, [](double x) -&gt; double { return sin(x); });\n    tabulate(-6.0, 6.0, 0.2, q);\n\n    tabulate_c(-6.0, 6.0, 0.2, [](double x) -&gt; double { return sin(x); });\n    tabulate_c(-6.0, 6.0, 0.2, q);\n}\n</code></pre>   <pre><code>9 7 6 5 4 3 1 0\n0 1 3 4 5 6 7 9\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#query-functions","title":"Query functions <p>The C++ algorithm library contains many functions for querying data structures. First, the standard library includes several logical functions that return true or false depending on what a query function returns for each element in the structure. The std::all_of() function returns true if the query function returns true for all elements. The query function in this case takes the values as input and returns true if the condition is fulfilled for this value. In the following example the function will return true if all elements are less than 10.</p> <pre><code>std::vector v = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\nif (std::all_of(v.begin(), v.end(), [](int i) { return i &lt; 10; }))\n    std::cout &lt;&lt; \"All values of v are less than 10.\" &lt;&lt; std::endl;\n</code></pre> <p>This will display:</p> <pre><code>All values of v are less than 10.\n</code></pre> <p>The next similar function is std::any_of(). This function returns true if any of the values in the data structure returns true in the evaluation function. </p> <pre><code>std::vector v = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\nif (std::any_of(v.begin(), v.end(), [](int i) { return i % 2 == 0; }))\n    std::cout &lt;&lt; \"Some of the values are even.\" &lt;&lt; std::endl;\n</code></pre> <p>This will display:</p> <pre><code>Some of the values are even.\n</code></pre> <p>Finally there is the std::none_of() function. This function returns true no of the values return true in the evaluation function.</p> <pre><code>std::vector v = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\nif (std::none_of(v.begin(), v.end(), [](int i) { return i &lt; 0; }))\n    std::cout &lt;&lt; \"No numbers are less than zero.\" &lt;&lt; std::endl;\n</code></pre> <p>This will display:</p> <pre><code>No numbers are less than zero.\n</code></pre> <p>There are also function for counting the number of values that fulfill certain criteria, std::count() and std::count_if(). The std::count() counts the values that correspond to the last argument of the function.</p> <pre><code>auto number_of_values = std::count(v.begin(), v.end(), 5);\nstd::cout &lt;&lt; number_of_values &lt;&lt; \" items with the value 5 in v2. \" &lt;&lt; std::endl;\n</code></pre> <p>This will display:</p> <pre><code>1 items with the value 5 in v2.\n</code></pre> <p>The std::count_if() function counts the number of values that return true in the evaluation function.</p> <pre><code>auto even_numbers = std::count_if(v.begin(), v.end(), [](int i) {return i % 2 == 0; });\nstd::cout &lt;&lt; even_numbers &lt;&lt; \" even numbers in v2.\" &lt;&lt; std::endl;\n</code></pre> <p>This will display:</p> <pre><code>3 even numbers in v2.\n</code></pre> <p>A complete interactive example is provided below:</p> ExampleOutput   <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n\nint main()\n{\n    std::vector v = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\n    if (std::all_of(v.begin(), v.end(), [](int i) { return i &lt; 10; }))\n        std::cout &lt;&lt; \"All values of v are less than 10.\" &lt;&lt; std::endl;\n\n    if (std::any_of(v.begin(), v.end(), [](int i) { return i % 2 == 0; }))\n        std::cout &lt;&lt; \"Some of the values are even.\" &lt;&lt; std::endl;\n\n    if (std::none_of(v.begin(), v.end(), [](int i) { return i &lt; 0; }))\n        std::cout &lt;&lt; \"No numbers are less than zero.\" &lt;&lt; std::endl;\n\n    if (std::ranges::all_of(v, [](int i) { return i &lt; 10; }))\n        std::cout &lt;&lt; \"All values of v are less than 10. (ranges)\" &lt;&lt; std::endl;\n\n    if (std::ranges::any_of(v, [](int i) { return i % 2 == 0; }))\n        std::cout &lt;&lt; \"Some of the values are even. (ranges)\" &lt;&lt; std::endl;\n\n    if (std::ranges::none_of(v, [](int i) { return i &lt; 0; }))\n        std::cout &lt;&lt; \"No numbers are less than zero. (ranges)\" &lt;&lt; std::endl;\n\n    auto number_of_values = std::count(v.begin(), v.end(), 5);\n    std::cout &lt;&lt; number_of_values &lt;&lt; \" items with the value 5 in v2. \" &lt;&lt; std::endl;\n\n    number_of_values = std::ranges::count(v, 5);\n    std::cout &lt;&lt; number_of_values &lt;&lt; \" items with the value 5 in v2. \" &lt;&lt; std::endl;\n\n    auto even_numbers = std::count_if(v.begin(), v.end(), [](int i) {return i % 2 == 0; });\n    std::cout &lt;&lt; even_numbers &lt;&lt; \" even numbers in v2.\" &lt;&lt; std::endl;\n\n    even_numbers = std::ranges::count_if(v, [](int i) {return i % 2 == 0; });\n    std::cout &lt;&lt; even_numbers &lt;&lt; \" even numbers in v2 (ranges).\" &lt;&lt; std::endl;\n}\n</code></pre>   <pre><code>All values of v are less than 10.\nSome of the values are even.\nNo numbers are less than zero.\nAll values of v are less than 10. (ranges)\nSome of the values are even. (ranges)\nNo numbers are less than zero. (ranges)\n1 items with the value 5 in v2.\n1 items with the value 5 in v2.\n3 even numbers in v2.\n3 even numbers in v2 (ranges).\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#iterating-with-for_each","title":"Iterating with for_each <p>Another useful function when working with data structure is std::for_each(). This function will iterate over the items in the data structure calling a provided function for each item. In the following example a function is called printing out the value of the current item.</p> <pre><code>std::vector v = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\nstd::for_each(v.begin(), v.end(), [](int i) { std::cout &lt;&lt; i &lt;&lt; \" \"; });\nstd::cout &lt;&lt; std::endl;\n</code></pre> <p>This will display:</p> <pre><code>6 4 7 3 9 0 1 5\n</code></pre> <p>The provided function is called with the current value as argument. It is also possible to modify the current value by passing the current value by references as shown in the example below:</p> <pre><code>std::vector v = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\nstd::for_each(v.begin(), v.end(), [](int&amp; n) { n++; });\nprint_vector(v);\n</code></pre> <p>This will display:</p> <pre><code>7 5 8 4 10 1 2 6\n</code></pre> <p>Using **std::for_each() it is possible to quickly sum all elements in a vector.</p> <pre><code>auto sum = 0;\n\nstd::for_each(v.begin(), v.end(), [&amp;sum](int n) { sum += n; });\nstd::cout &lt;&lt; \"Them sum is \" &lt;&lt; sum &lt;&lt; std::endl;\n</code></pre>  <p>Note</p> <p>It is important to make sure that the closure includes the outside variable for the sum by reference (&amp;).</p>  <p>A complete interactive example is provided below:</p> ExampleOutput   <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n\n\nvoid print_vector(auto v)\n{\n    for (auto&amp; item : v)\n        std::cout &lt;&lt; item &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n    std::vector v = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\n    std::for_each(v.begin(), v.end(), [](int i) { std::cout &lt;&lt; i &lt;&lt; \" \"; });\n    std::cout &lt;&lt; std::endl;\n\n    std::ranges::for_each(v, [](int i) { std::cout &lt;&lt; i &lt;&lt; \" \"; });\n    std::cout &lt;&lt; std::endl;\n\n    std::for_each(v.begin(), v.end(), [](int&amp; n) { n++; });\n    print_vector(v);\n\n    std::ranges::for_each(v, [](int&amp; n) { n++; });\n    print_vector(v);\n\n    auto sum = 0;\n\n    std::for_each(v.begin(), v.end(), [&amp;sum](int n) { sum += n; });\n    std::cout &lt;&lt; \"Them sum is \" &lt;&lt; sum &lt;&lt; std::endl;\n\n    sum = 0;\n\n    std::ranges::for_each(v, [&amp;sum](int n) { sum += n; });\n    std::cout &lt;&lt; \"Them sum is \" &lt;&lt; sum &lt;&lt; std::endl;\n\n    print_vector(v);\n\n}\n</code></pre>   <pre><code>6 4 7 3 9 0 1 5\n6 4 7 3 9 0 1 5\n7 5 8 4 10 1 2 6\n8 6 9 5 11 2 3 7\nThem sum is 51\nThem sum is 51\n8 6 9 5 11 2 3 7\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#copying","title":"Copying <p>Copying is a very common operation on data structures. The standard library contains many functions for copying data between different data structures. The first one is std::copy() which copies from a data structure given by a starting and end iterator to a target data structure given by the starting iterator. An example of this is shown below:</p> <pre><code>std::vector v1 = { 6, 4, 7, 3, 9, 0, 1, 5 };\nstd::vector v2 = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\nstd::copy(v1.begin(), v1.end(), v2.begin());\n\nprint_vector(v2);\n</code></pre> <p>The resulting output will be:</p> <pre><code>6 4 7 3 9 0 1 5\n</code></pre> <p>It is also possible to copy values from one data structure and inserting them at the back or front of the target. To do this we need to use a special function std::back_inserter() as shown in the example below:</p> <pre><code>std::copy(v1.begin(), v1.end(), std::back_inserter(v2));\n\nprint_vector(v2);\n</code></pre> <p>which gives the following output:</p> <pre><code>6 4 7 3 9 0 1 5 6 4 7 3 9 0 1 5\n</code></pre> <p>There is a second form of copy function, std::copy_if(), which works like std::copy(), but where it is possible to supply a function that returns true if the function should perform the copy. The function takes the value of the data structure as input. An example of this is shown below:</p> <pre><code>std::copy_if(v1.begin(), v1.end(), std::back_inserter(v3), [](int v) {return v % 2 == 0; });\n\nprint_vector(v3);\n</code></pre> <p>Her we can see that std::copy_if() only copied even numbers.</p> <pre><code>6 4 0\n</code></pre> <p>It is also possible to copy values from one data structure to the end of another using the std::copy_backward(). This function takes the start, end iterators of the source data structure and an end-iterator of the data structure to copy from. The function will preserve the order of the values in the source data structure when copying. An example of how to use this function is shown in the following example:</p> <pre><code>std::vector v1 = { 6, 4, 7, 3, 9, 0, 1, 5 };\nstd::vector&lt;int&gt; v4(20);\n\nstd::copy_backward(v1.begin(), v1.end(), v4.end());\n\nprint_vector(v4);\n</code></pre> <p>As shown in the output below</p> <pre><code>0 0 0 0 0 0 0 0 0 0 0 0 6 4 7 3 9 0 1 5 \n</code></pre> <p>the values of v1 is copied and placed at the end of v4. </p> <p>A complete interactive example is provided below:</p> ExampleOutput   <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid print_vector(auto v)\n{\n    for (auto&amp; item : v)\n        std::cout &lt;&lt; item &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n    std::vector v1 = { 6, 4, 7, 3, 9, 0, 1, 5 };\n    std::vector v2 = { 0, 0, 0, 0, 0, 0, 0, 0 };\n    std::vector&lt;int&gt; v3;\n\n    std::copy(v1.begin(), v1.end(), v2.begin());\n\n    print_vector(v2);\n\n    std::copy(v1.begin(), v1.end(), std::back_inserter(v2));\n\n    print_vector(v2);\n\n    std::copy_if(v1.begin(), v1.end(), std::back_inserter(v3), [](int v) {return v % 2 == 0;});\n\n    print_vector(v3);\n\n    std::vector&lt;int&gt; v4(20);\n\n    std::copy_backward(v1.begin(), v1.end(), v4.end());\n\n    print_vector(v4);\n}\n</code></pre>   <pre><code>6 4 7 3 9 0 1 5\n6 4 7 3 9 0 1 5 6 4 7 3 9 0 1 5\n6 4 0\n0 0 0 0 0 0 0 0 0 0 0 0 6 4 7 3 9 0 1 5\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#transforming-replacing","title":"Transforming / Replacing <p>The C++ standard function std::transform() can be used to transform existing values either to a different container or the source container. The function does not guarantee that the operation will be applied in order. If in-order execution is desired the std::for_each() function is a better choice.</p> <p>std::transform() takes start/end iterator, destination iterator and a modification function as input. Please note that the methods cbegin() and cend() methods must be used to get constant iterators for the 2 first arguments. This is due to the fact that the function is not allowed to modify the input value. In the following code we apply a function to v1 and modify v1 in place.</p> <pre><code>std::vector v1 = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\nstd::transform(v1.cbegin(), v1.cend(), v1.begin(), [](int v){return v*v;});\n\nprint_vector(v1);\n</code></pre> <p>This will give the following output:</p> <pre><code>36 16 49 9 81 0 1 25\n</code></pre> <p>It is also possible to store the result in a different container:</p> <pre><code>std::vector&lt;int&gt; v2(8);\n\nstd::transform(v1.cbegin(), v1.cend(), v2.begin(), [](int v){return v*v;});\n\nprint_vector(v2);\n</code></pre> <p>Here we create an empty container, v2, which we will use to store the transformed values, which gives the following result:</p> <pre><code>1296 256 2401 81 6561 0 1 625\n</code></pre> <p>It is of course also possible to insert the items at the end of a container using the std::back_inserter() function as shown below.</p> <pre><code>std::vector&lt;int&gt; v3;\n\nstd::transform(v1.cbegin(), v1.cend(), std::back_inserter(v3), [](int v){return v*v;});\n</code></pre> <p>A complete interactive example is provided below:</p> ExampleOutput   <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid print_vector(auto v)\n{\n    for (auto&amp; item : v)\n        std::cout &lt;&lt; item &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n    std::vector v1 = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\n    std::transform(v1.cbegin(), v1.cend(), v1.begin(), [](int v){return v*v;});\n\n    print_vector(v1);\n\n    std::vector&lt;int&gt; v2(8);\n\n    std::transform(v1.cbegin(), v1.cend(), v2.begin(), [](int v){return v*v;});\n\n    print_vector(v2);\n\n    std::vector&lt;int&gt; v3;\n\n    std::transform(v1.cbegin(), v1.cend(), std::back_inserter(v3), [](int v){return v*v;});\n\n    print_vector(v3);\n}\n</code></pre>   <pre><code>36 16 49 9 81 0 1 25\n1296 256 2401 81 6561 0 1 625\n1296 256 2401 81 6561 0 1 625\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#removing-elements","title":"Removing elements <p>In previous chapters, we have used the built-in methods in the containers to remove elements within the container. It is also possible to remove elements from containers using the std::remove(), std::remove_if() and std::unique() functions. These functions work in combination with the .erase() methods of the specific container. </p> <p>The std::remove() method removes specific items that are equal to the argument given in the call. An example of this is shown below:</p> <pre><code>std::vector v1 = { 6, 4, 7, 3, 9, 0, 1, 5 };\n\nauto removed_item = std::remove(v1.begin(), v1.end(), 9);\n\nif (removed_item != v1.end())\n    v1.erase(removed_item, v1.end());\n\nprint_vector(v1);\n</code></pre> <p>Which gives the following output:</p> <pre><code>6 4 7 3 0 1 5\n</code></pre> <p>When std::remove() removes items by moving them to the end of the container. The returned iterator points to the first element to be erased in the container. This is the reason for giving a starting and an end iterator for the v1.erase() call.</p> <p>Using the std::remove_if() function it is possible to provide a function for determining if a value in the container should be removed. The function should return true if it should be removed. In the following example, we use a function to remove all even values.</p> <pre><code>removed_item = std::remove_if(v1.begin(), v1.end(), [](int v)\n    { return v % 2 == 0; });\n\nif (removed_item != v1.end())\n    v1.erase(removed_item, v1.end());\n\nprint_vector(v1);\n</code></pre> <p>Running this example with give the following output:</p> <pre><code>7 3 1 5\n</code></pre> <p>Another function that can be useful is the std::unique() function. This functions remove repeated values in a container. Combined with the std::sort() function it is possible to extract the unique values in a container as shown in the next example:</p> <pre><code>std::vector v2 = { 4, 5, 7, 4, 3, 3, 7, 7, 4, 5 };\n\nauto last = std::unique(v2.begin(), v2.end());\nv2.erase(last, v2.end());\n\nstd::sort(v2.begin(), v2.end());\n\nlast = std::unique(v2.begin(), v2.end());\nv2.erase(last, v2.end());\n\nprint_vector(v2);\n</code></pre> <p>This gives the following output:</p> <pre><code>3 4 5 7\n</code></pre> <p>A complete interactive example is provided below:</p> ExampleOutput   <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid print_vector(auto v)\n{\n    for (auto&amp; item : v)\n        std::cout &lt;&lt; item &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n    std::vector v1 = { 6, 4, 7, 3, 9, 0, 1, 5, 9 };\n\n    auto removed_item = std::remove(v1.begin(), v1.end(), 9);\n\n    if (removed_item != v1.end())\n        v1.erase(removed_item, v1.end());\n\n    print_vector(v1);\n\n    removed_item = std::remove_if(v1.begin(), v1.end(), [](int v)\n        { return v % 2 == 0; });\n\n    if (removed_item != v1.end())\n        v1.erase(removed_item, v1.end());\n\n    print_vector(v1);\n\n    std::vector v2 = { 4, 5, 7, 4, 3, 3, 7, 7, 4, 5 };\n    // std::vector v2 = { 1, 2, 3, 4, 5 };\n\n    auto last = std::unique(v2.begin(), v2.end());\n    v2.erase(last, v2.end());\n\n    std::sort(v2.begin(), v2.end());\n\n    last = std::unique(v2.begin(), v2.end());\n    v2.erase(last, v2.end());\n\n    print_vector(v2);\n}\n</code></pre>   <pre><code>6 4 7 3 0 1 5\n7 3 1 5\n3 4 5 7\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#numeric-operations","title":"Numeric operations <p>The algorithm library also contains several functions for performing numerical operations. The first function that can be useful is the std::iota() function. This function can generate series of values in a container. It is used by giving a start and end iterator and a starting value as shown in the following example:</p> <pre><code>std::vector&lt;double&gt; v1(20);\n\nstd::iota(v1.begin(), v1.end(), 1.0);\n\nprint_vector(v1);\n</code></pre> <p>which prints</p> <pre><code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n</code></pre> <p>Another function that can be useful for computational use is std::accumulate(). This function takes accumulates values from a given starting value with a specified operation, that can be given as a built-in operation or a custom function. If no function is given the total sum of the values will be calculated as shown below:</p> <pre><code>auto sum = std::accumulate(v1.begin(), v1.end(), 0.0);\n\nstd::cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; \"\\n\";\n</code></pre> <p>Which will display the following output</p> <pre><code>sum = 210\n</code></pre> <p>If we instead want to compute the total product we can provide a standard operation as an additional argument</p> <pre><code>auto prod = std::accumulate(v1.begin(), v1.end(), 1.0, std::multiplies&lt;double&gt;());\n\nstd::cout &lt;&lt; \"prod = \" &lt;&lt; prod &lt;&lt; \"\\n\";\n</code></pre> <p>this prints</p> <pre><code>prod = 2.4329e+18\n</code></pre> <p>A complete interactive example is provided below:</p> ExampleOutput   <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nvoid print_vector(auto v)\n{\n    for (auto&amp; item : v)\n        std::cout &lt;&lt; item &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n    std::vector&lt;double&gt; v1(20);\n\n    std::iota(v1.begin(), v1.end(), 1.0);\n\n    print_vector(v1);\n\n    auto sum = std::accumulate(v1.begin(), v1.end(), 0.0);\n\n    std::cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; \"\\n\";\n\n    auto prod = std::accumulate(v1.begin(), v1.end(), 1.0, std::multiplies&lt;double&gt;());\n\n    std::cout &lt;&lt; \"prod = \" &lt;&lt; prod &lt;&lt; \"\\n\";\n}\n</code></pre>   <pre><code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\nsum = 210\nprod = 2.4329e+18\n</code></pre>    <p> Try example</p>","text":""},{"location":"data_structures_algorithms/#constrained-algorithms","title":"Constrained algorithms <p>In C++20 new forms of functions were introduced to the algorithms library which enables you to supply your container as an argument to the function without iterators. This enables a more intuitive and easy-to-understand syntax for many of the functions. As an example the following std::for_each() call </p> <pre><code>std::for_each(v.begin(), v.end(), [](int i) { std::cout &lt;&lt; i &lt;&lt; \" \"; });\nstd::cout &lt;&lt; std::endl;\n</code></pre> <p>can be converted to </p> <pre><code>std::ranges::for_each(v, [](int i) { std::cout &lt;&lt; i &lt;&lt; \" \"; });\nstd::cout &lt;&lt; std::endl;\n</code></pre> <p>It is also possible to sort a container by a simple</p> <pre><code>std::ranges::sort(v);\n</code></pre> <p>All these functions are available in the std::ranges namespace. </p>","text":""},{"location":"data_structures_algorithms/#links-to-more-information","title":"Links to more information <p>This chapter only gives an overview of how containers and algorithms in C++ can be used more information on available data structures and algorithms can be found att cppreference.com here:</p> <p> cppreference.com</p>","text":""},{"location":"debugging/","title":"Debugging your application.","text":""},{"location":"history/","title":"C++ History","text":"<p>C++ is a relatively new language. It was created by Bjarne Stroustrup in 1979 when he started work on \"C with Classes\". He was inspired by Simula which was used in large software development. However, it was too slow for practical use. </p> <p>\"C with Classes\" included features like classes, derived classes, strong type checking, inlining, default arguments, and argument type checking. </p> <p>In 1982 he started work on a C successor and it was also then it was renamed to C++. </p> <p>In 1985 the first edition of \"The C++ Programming Language\" was published. It was the first book to describe the C++ language. The first compiler was release in october the same year.</p> <p>In 1989 C++ 2.0 was released. It was a minor revision of the language. An update of the \"The C++ Programming Language\" book was also released. This version included features like multiple inheritance, abstract classes, static member functions, const member functions, and protected members.</p> <p>In 1998 C++98 was released, which also standardized the language. </p> <p>After this the language was standardized every three years. Currently released standards include C++03, C++11, C++14, and C++17, C++20 and C++23.</p> <p>For more information see Wikipedia or Bjarne Stroustrup's homepage.</p>"},{"location":"input_output/","title":"Input and output","text":"<p>One important aspect of programming is the ability to read and write from standard input/output and from files in different ways. In C++ the main way of reading and writing data is using the stream classes in the C++ input/output library. Using streams, data can be read and written using special operators to files. It is also possible to read and write to stream in memory. </p> <p>The stream classes are defined in the iostreams header which is included with the following code:</p> <pre><code>#include &lt;iostreams&gt;\n</code></pre> <p>The classes in iostreams are defined in the std:: namespace, so if we want to use them directly they have to be prefixed with std::. For the examples in this chapter we will avoid this by adding the following statement in before use:</p> <pre><code>using namespace std;\n</code></pre> <p>Note</p> <p>Adding this statement is not recommended for larger projects, as it can bring in unnecessary namespaces in the code. This is especially important in header files.</p>"},{"location":"input_output/#reading-and-writing-to-the-console","title":"Reading and writing to the console","text":"<p>There are 3 built-in stream objects available for reading and writing to standard input - cin, standard output - cout and standard error - cerr. We have already used these objects in the previous sections without going into the details of how these work. </p> <p>Writing to a stream is accomplished using the &lt;&lt; operator followed by the variable, scalable or string that you want to write. Writing is done continuously on a single line until a special manipulator, endl, is passed to the stream. In the following example 3 variables are written to 2 lines of output:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a = 1;\n    int b = 2;\n    double c = 3.0;\n\n    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b;\n    cout &lt;&lt; \" \" &lt;&lt; c &lt;&lt; endl;\n    cout &lt;&lt; &amp;c &lt;&lt; endl;\n}\n</code></pre> <p>Which gives the following output.</p> <pre><code>1 2 3\n0x559fff6f0\n</code></pre> <p>The variables a, b and c are all written on the same line as the endl marker is passed after writing the c variable. You can also notice that passing a memory address to the stream will automatically format it as a hexadecimal memory address. </p> <p>Reading from a stream is done by using the &gt;&gt; operator followed by the variables that should be assigned from the input stream. How cin is used is shown in the example below:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a;\n    int b;\n    double c;\n\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n    cout &lt;&lt; \"a = \" &lt;&lt; a;\n    cout &lt;&lt; \", b = \" &lt;&lt; b;\n    cout &lt;&lt; \", c = \" &lt;&lt; c &lt;&lt; endl;\n}\n</code></pre> <p>In the example above the program will wait for 2 integers and a floating point number to be entered in the console before printing out the values in the cout statements.</p>"},{"location":"input_output/#formatting-output-using-manipulators","title":"Formatting output using manipulators","text":"<p>To better control how output is written C++ provides a special manipulator operators that can be passed in the stream output to control the output of data written to the stream. To use this functionality we need to use the following include:</p> <pre><code>#include &lt;iomanip&gt;\n</code></pre> <p>To control the width the output variables, the setw(...) manipulator can be used. This manipulator often needs to be called mutiple times as the width is usually reset if a &gt;&gt; or &lt;&lt; operators are used. It is also possible to control left and right alignment using the left and right manipulators. The character used to pad the output is set by the setfill(...) method and the precision of floating point values are set by the setprecision(...) manipulator. A complete example of using these manipulators is shown below:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    double pi = 4 * std::atan(1);\n    double x = 0.0;\n    double dx = 0.1;\n\n    cout &lt;&lt; setw(15) &lt;&lt; left &lt;&lt; \"X\";\n    cout &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; \"f(x)\" &lt;&lt; endl;\n    cout &lt;&lt; setfill('-');\n    cout &lt;&lt; setw(25) &lt;&lt; \"\" &lt;&lt; endl;\n    cout &lt;&lt; setfill(' ');\n    cout &lt;&lt; setprecision(6) &lt;&lt; fixed;\n    //cout.unsetf(ios_base::fixed);\n\n    while (x&lt;=pi*0.25)\n    {\n        cout &lt;&lt; setw(15) &lt;&lt; left &lt;&lt; x;\n        cout &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; sin(x);\n        cout &lt;&lt; endl;\n        x += dx;\n    }\n}\n</code></pre> <p>The code shown above will print a function table of the sin(x) function.</p> <pre><code>X                    f(x)\n-------------------------\n0.000000         0.000000\n0.100000         0.099833\n0.200000         0.198669\n0.300000         0.295520\n0.400000         0.389418\n0.500000         0.479426\n0.600000         0.564642\n0.700000         0.644218\n</code></pre> <p>It is also possible to specifiy if a boolean value should be printed as 0 or 1 or with true and false.</p> <pre><code>bool flag = true;\n\ncout &lt;&lt; \"flag = \" &lt;&lt; flag &lt;&lt; endl;\ncout &lt;&lt; boolalpha;\ncout &lt;&lt; \"flag = \" &lt;&lt; flag &lt;&lt; endl;\n</code></pre> <p>This prints:</p> <pre><code>flag = 1\nflag = true\n</code></pre> <p>It is also possible to output values in different numerical bases using the hex, dec and oct manipulators. The showbase manipulator determines if output show the base in the output. The following code outputs the n integer in different bases.</p> <pre><code>int n = 42;\n\ncout &lt;&lt; hex &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\ncout &lt;&lt; hex &lt;&lt; showbase &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\ncout &lt;&lt; oct &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\ncout &lt;&lt; dec &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\n</code></pre> <p>This outputs the following:</p> <pre><code>n = 2a\nn = 0x2a\nn = 052\nn = 42\n</code></pre> <p>The complete example is shown below:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nint main()\n{\n    bool flag = true;\n\n    cout &lt;&lt; \"flag = \" &lt;&lt; flag &lt;&lt; endl;\n    cout &lt;&lt; boolalpha;\n    cout &lt;&lt; \"flag = \" &lt;&lt; flag &lt;&lt; endl;\n\n    int n = 42;\n\n    cout &lt;&lt; hex &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\n    cout &lt;&lt; hex &lt;&lt; showbase &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\n    cout &lt;&lt; oct &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\n    cout &lt;&lt; dec &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\n}\n</code></pre> <p>There are a lot more manipulators available in the iomanip header. For more information please see:</p> <p> iomanip att cppreference.com</p>"},{"location":"input_output/#reading-and-writing-to-files-streams","title":"Reading and writing to files (streams)","text":"<p>To read and write data to files we need to instantiate stream instances for each file operation. There are 3 main file stream classes in C++:</p> <ul> <li>ofstream \u2013 output file stream</li> <li>ifstream \u2013 input file stream</li> <li>fstream \u2013 generic file stream</li> </ul> <p>These classes are defined in the fstream standard header. Just like the cout and cin streams the file streams also use &lt;&lt; and &gt;&gt; operators for input and output. </p>"},{"location":"input_output/#writing-to-a-file-ofstream","title":"Writing to a file (ofstream)","text":"<p>To open a file for writing we can use the ofstream class. The first step in writing to the file is to instantiate an output file stream.</p> <pre><code>ofstream myfile;\n</code></pre> <p>Next, we open the file using the open()-method.</p> <pre><code>myfile.open(\"myfile.txt\");\n</code></pre> <p>As this is an output file stream we don't have to give any more arguments to the open()-method. The file is now open for writing and we can use the &lt;&lt;-operator for writing to the output stream.</p> <pre><code>myfile &lt;&lt; \"Hello file!\" &lt;&lt; endl;\nmyfile &lt;&lt; \"Second line\" &lt;&lt; endl;\n</code></pre> <p>In the output to the file we can use the same manipulators as when we were outputting to the cout standard output stream. The last statements will write 2 rows to the file myfile.txt. </p> <p>The final step when reading and writing files is to tell the operating system that we will not work with the file anymore. This is done using the .close() method of the ofstream instance.</p> <pre><code>myfile.close();\n</code></pre> <p>The complete example is shown below:</p> CodeOutput (myfile.txt) <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nint main()\n{\n    ofstream myfile;\n    myfile.open(\"myfile.txt\");\n    myfile &lt;&lt; \"Hello file!\" &lt;&lt; endl;\n    myfile &lt;&lt; \"Second line\" &lt;&lt; endl;\n    myfile.close();\n}\n</code></pre> <pre><code>Hello file!\nSecond line\n</code></pre>"},{"location":"input_output/#appending-to-a-file","title":"Appending to a file","text":"<p>The default behavior when writing to a file using the ofstream is to overwrite any existing file. If we want to append data to an existing file we can specify this using the second argument to the .open()-method, ios::app.</p> <pre><code>myfile.open(\"myfile.txt\", ios::app);\n</code></pre> <p>Everything we write to the stream will now be appended to the existing file.</p> <pre><code>outfile &lt;&lt; \"Third line\" &lt;&lt; endl;\noutfile.close();\n</code></pre> <p>This will add \"Third line\" as the third line of the myfile.txt file.</p>"},{"location":"input_output/#reading-from-a-file-ifstream","title":"Reading from a file (ifstream)","text":"<p>Reading from a file is done with the same steps as writing to a file. First, we instantiate an ifstream instance.</p> <pre><code>ifstream myfile(\"myfile.txt\");\n</code></pre> <p>When reading from a file it is always a good idea to make sure the file has been succesfully opened. This can be done using the .is_open() method of the stream instance.</p> <pre><code>if (!myfile.is_open())\n{\n    cout &lt;&lt; \"The file couldn't be opened.\\n\";\n    return;\n}\n</code></pre> <p>A more generic way of checking if a file stream is ready for operations is to use the .good()-method. This method returns true if the file stream is ready for operations.</p> <pre><code>if (!myfile.good())\n    return\n</code></pre> <p>Reading from a file requires the file to have the data in a way that the file operators can interpret. Reading data types from a file requires them to be present in the same way as they were written to the file. Writing the variables a, b and c to disk as shown in the followng example </p> <pre><code>int a = 1;\nint b = 2;\nint c = 3;\nmyfile &lt;&lt; a &lt;&lt; b &lt;&lt; c;\n</code></pre> <p>will produce the following output to the file:</p> <pre><code>123\n</code></pre> <p>This is probarbly not what you want and it will be impossible to read the data back again as integers. To write data to a file so that it is possible to read back we need to modify our example by adding space between the variables in the output.</p> <pre><code>myfile &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \" \"&lt;&lt; c;\n</code></pre> <p>This produces the following output to the file:</p> <pre><code>1 2 3\n</code></pre> <p>Now it is also possible to read the data back from the file stream using the following statements:</p> <pre><code>myfile &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n</code></pre> <p>Notice that variables must be added in the same order as we wrote them to the file. We don't have to handle the extra spaces. Spaces between numbers in a file will automatically handled by the input operators.</p>"},{"location":"input_output/#a-larger-example","title":"A larger example","text":"<p>To illustrate reading and writing values to a file we will create a program that will tabulate a function and write this to the file inputfile.dat. We start by creating an output stream for writing:</p> <pre><code>double pi = 4 * std::atan(1);\ndouble x = 0.0;\ndouble y;\ndouble dx = 0.1;\n\nofstream outfile;\noutfile.open(\"inputfile.dat\", ios::out);\n</code></pre> <p>Next, we use a while-loop to tabulate sin(x) from 0 to pi/4. For each row of the file we write the x value and the corresponding function value.</p> <pre><code>while (x&lt;=pi*0.25)\n{\n    outfile &lt;&lt; x &lt;&lt; \" \" &lt;&lt; sin(x) &lt;&lt; endl;\n    x += dx;\n}\noutfile.close(); // Close file when we are done.\n</code></pre> <p>Notice that we add an extra space between x and sin(x). When running this code the file inputfile.dat will contain the following:</p> <pre><code>0 0\n0.1 0.0998334\n0.2 0.198669\n0.3 0.29552\n0.4 0.389418\n0.5 0.479426\n0.6 0.564642\n0.7 0.644218\n</code></pre> <p>To read the data back from inputfile.dat we instantiate a ifstream instance.</p> <pre><code>ifstream infile;\ninfile.open(\"inputfile.dat\");\n</code></pre> <p>Using a while-statement again we will read the file back. We use the .good() method to determine if we should exit the while-statement. As the input file contains values in the expected format we easily use the &gt;&gt;-operator for reading x and function values from the file.</p> <pre><code>while (infile.good())\n{\n    infile &gt;&gt; x &gt;&gt; y;\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl;\n}\ninfile.close();\n</code></pre> <p>Output from the application will then be:</p> <pre><code>x = 0, y = 0\nx = 0.1, y = 0.0998334\nx = 0.2, y = 0.198669\nx = 0.3, y = 0.29552\nx = 0.4, y = 0.389418\nx = 0.5, y = 0.479426\nx = 0.6, y = 0.564642\nx = 0.7, y = 0.644218\nx = 0.7, y = 0.644218\n</code></pre> <p>The complete example can be found here:</p> CodeOutput (myfile.txt) <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    double pi = 4 * std::atan(1);\n    double x = 0.0;\n    double y;\n    double dx = 0.1;\n\n    ofstream outfile;\n    outfile.open(\"inputfile.dat\", ios::out);\n    while (x&lt;=pi*0.25)\n    {\n        outfile &lt;&lt; x &lt;&lt; \" \" &lt;&lt; sin(x) &lt;&lt; endl;\n        x += dx;\n    }\n    outfile.close();\n\n    ifstream infile;\n    infile.open(\"inputfile.dat\");\n    while (infile.good())\n    {\n        infile &gt;&gt; x &gt;&gt; y;\n        cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl;\n    }\n    infile.close();\n}\n</code></pre> <pre><code>x = 0, y = 0\nx = 0.1, y = 0.0998334\nx = 0.2, y = 0.198669\nx = 0.3, y = 0.29552\nx = 0.4, y = 0.389418\nx = 0.5, y = 0.479426\nx = 0.6, y = 0.564642\nx = 0.7, y = 0.644218\nx = 0.7, y = 0.644218\n</code></pre> <p> Try example</p>"},{"location":"input_output/#reading-text-files","title":"Reading text files","text":"<p>Sometimes you want to read a text file and process the file yourself. To do this you can't use the standard stream operators. To read text from a file we use the standard library function std::getline() from the sstream header. This function takes a stream as input and a string containing the line that has been read from the file. In the following example we will read from a text file containing power consumtion data in CSV format. The first column contains the date for the sample and the second column contains the power consumtion value. First we open the file:</p> <pre><code>string line;\nifstream infile;\ninfile.open(\"..\\\\..\\\\data\\\\AEP_hourly.csv\");\n\nif (!infile.is_open())\n{\n    cout &lt;&lt; \"Error opening file\" &lt;&lt; endl;\n    return 1;\n}\n</code></pre> <p>We then do a while-loop over the file calling std::getline(...) to read the file line by line.</p> <pre><code>while (infile.good())\n{\n    getline(infile, line);\n    cout &lt;&lt; line &lt;&lt; endl;\n}\ninfile.close();\n</code></pre> <p>Running the example will print out something similar to:</p> <pre><code>...\n2006-05-23 12:00:00,15486.0\n2006-05-23 13:00:00,15545.0\n2006-05-23 14:00:00,15437.0\n2006-05-23 15:00:00,15455.0\n2006-05-23 16:00:00,15597.0\n2006-05-23 17:00:00,15437.0\n2006-05-23 18:00:00,15293.0\n2006-05-23 19:00:00,15058.0\n2006-05-23 20:00:00,14971.0\n2006-05-23 21:00:00,15166.0\n...\n</code></pre>"},{"location":"input_output/#splitting-lines","title":"Splitting lines","text":"<p>To separate the date from the value we need to do some basic string manipulation. First we need to find the position of the comma in the line. We can do this with the std::find(...) method. This function will return a string iterator at the position of the comma or end end() iterator. We can then use the .substr() method of the string to extract the date and value fields. The code then becomes:</p> <pre><code>while (infile.good())\n{\n    getline(infile, line);\n\n    auto pos = std::find(line.begin(), line.end(), ',');\n\n    if (pos != line.end())\n    {\n        string date = line.substr(0, pos - line.begin());\n        string value = line.substr(pos - line.begin() + 1);\n\n        std::cout &lt;&lt; \"date:  \" &lt;&lt; date &lt;&lt; \" value: \" &lt;&lt; value &lt;&lt; \"\\n\";\n    }\n}\n</code></pre> <p>Running this code produces the following output:</p> <pre><code>date:  2018-01-01 12:00:00 value: 19453.0\ndate:  2018-01-01 13:00:00 value: 19049.0\ndate:  2018-01-01 14:00:00 value: 18737.0\ndate:  2018-01-01 15:00:00 value: 18619.0\ndate:  2018-01-01 16:00:00 value: 18691.0\ndate:  2018-01-01 17:00:00 value: 19109.0\ndate:  2018-01-01 18:00:00 value: 20279.0\ndate:  2018-01-01 19:00:00 value: 20925.0\ndate:  2018-01-01 20:00:00 value: 21089.0\ndate:  2018-01-01 21:00:00 value: 20999.0\ndate:  2018-01-01 22:00:00 value: 20820.0\ndate:  2018-01-01 23:00:00 value: 20415.0\ndate:  2018-01-02 00:00:00 value: 19993.0\n</code></pre>"},{"location":"input_output/#converting-from-string-to-float","title":"Converting from string to float","text":"<p>If we want to convert the value field to a floating point type we can use the std::stod(...) or std::stof(...) functions. They throw an std::invalid_argument exception if the value can't be converted. The conversion can be handled using the following code:</p> <pre><code>double dval = 0.0;\n\ntry\n{\n    dval = std::stod(strValue);\n}\ncatch (const std::exception&amp; e)\n{\n    std::cerr &lt;&lt; e.what() &lt;&lt; '\\n';\n}\n\nstd::cout &lt;&lt; \"date:  \" &lt;&lt; date &lt;&lt; \" value: \" &lt;&lt; dval &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"input_output/#reading-binary-files","title":"Reading binary files","text":"<p>In the previous chapters we have seen how we can read and write data to text files. In many cases you will need to read and write data in binary format. Reading and writing to binary files are similar to the previous approach except that we add the ios::binary flag in the open-statement. and instead of using the &lt;&lt; and &gt;&gt; operators we use the stream methods .read(...) and .write(...) methods for read and write. I binary file can also consist of multiple parts with different data (records). To be able to read data at different parts of the file we use an invisble cursor that we can place at the location we want to read. This cursor can be set using the .seekg(...) method of the stream.</p>"},{"location":"input_output/#writing-data-to-a-binary-file","title":"Writing data to a binary file","text":"<p>In this example we are going to write a number of particles with position and mass to disk as a binary file. First we create a structure to hold the particle information.</p> <pre><code>struct Particle {\n    double x;\n    double y;\n    double mass;\n};\n</code></pre> <p>For this example we are going to write random data to our particles, so we initialise the random number generator.</p> <pre><code>srand((unsigned)time(0));\n</code></pre> <p>Next, we open a stream for binary write using the ios::binary flag.</p> <pre><code>ofstream particlesFile(\"particles.dat\", ios::out | ios::binary);\n</code></pre> <p>To write particle data to the file we need create a variable to hold the data to be written:</p> <pre><code>Particle p;\n</code></pre> <p>To write data to a binary file the .write() method takes a pointer to a buffer of the data to write and the size of the buffer. To get a size of a buffer we can use the sizeof() function in C++ to query and variable for its size. In the following code we write 10 particles to the binary file, particles.dat.</p> <pre><code>for (auto i = 0; i &lt; 10; i++)\n{\n    p.x = 100.0 * (double)rand() / (double)RAND_MAX;\n    p.y = 100.0 * (double)rand() / (double)RAND_MAX;\n    p.mass = 1.0 + (double)rand() / (double)RAND_MAX;\n\n    particlesFile.write((char*)&amp;p, sizeof(p));\n}\nparticlesFile.close();\n</code></pre> <p>Please note that we reuse the same variable with different data for each write, which is not always the case. The .write()-method requires a char pointer, which is why we need the cast p before passing it in the call. Also p is a local variable (on the stack), which is the reason we pass it as reference using the &amp; operator.</p> <p>When writing to a binary file the invisible file pointer is moved the size of the data writting every time you call the .write()-method.</p>"},{"location":"input_output/#reading-data-from-a-binary-file","title":"Reading data from a binary file","text":"<p>Reading data is very similar to writing data, except now we read from the file using the .read()-method and write data to a buffer of the right size. Be default the file pointer will be placed at the beginning of the file. In the following code a file object is opened for reading using the ios::binary flag.</p> <pre><code>ifstream inputParticlesFile(\"particles.dat\", ios::in | ios::binary);\n\nif (inputParticlesFile.is_open())\n{\n    while (inputParticlesFile.good())\n    {\n        inputParticlesFile.read((char*)&amp;p, sizeof(p));\n        cout &lt;&lt; \"x = \" &lt;&lt; p.x;\n        cout &lt;&lt; \", y = \" &lt;&lt; p.y;\n        cout &lt;&lt; \", m = \" &lt;&lt; p.mass &lt;&lt; endl;\n    }\n}\nelse\n    cout &lt;&lt; \"Could not open file.\" &lt;&lt; endl;\n</code></pre> <p>if we want to write more entries to the file at the end we can add the ios::ate flag when opening the file. The file pointer is then moved to the end of the file and the next entry written will be added after the last buffer written to the file.</p> <p>It is also possible to move the file pointer to the end of the file using the .seekg()-method of the file stream object. The following statement moves the file pointer to the beginning of the file. The first argument is the offset to move from the position and direction given by the second argument.  <pre><code>inputParticlesFile.seekg(0, ios::beg);\n</code></pre></p> <p>The second argument can be on of three alternatives</p> <ul> <li>ios::beg - search from the beginning of the file.</li> <li>ios::cur - search from the current position forward (+) and backwards (-).</li> <li>iso::end - search backwards from the end of the file.</li> </ul> <p>If only a single argument is given to the .seekg()-method, this argument is the absolute position in the file.</p>"},{"location":"input_output/#reading-elevations-from-a-binary-file","title":"Reading elevations from a binary file","text":"<p>To illustrate real-world usage of how to read data from binary file, we will open the the file ../data/colorado_elev.vit, which contains elevation values in a 400 x 400 image file. The first 268 bytes contains a header, which we will need to skip. The rest of the data contains the height values stored as unsigned bytes.</p> <p>First we open the file for writing, also checking that the file was opened.</p> <pre><code>ifstream infile;\ninfile.open(\"../data/colorado_elev.vit\", ios::in | ios::binary);\n\nif (!infile.is_open())\n{\n    cout &lt;&lt; \"Error opening file\" &lt;&lt; endl;\n    return 1;\n}\n</code></pre> <p>To be able to read the data from the file we need a buffer to store the unsigned bytes into. In this case we use a std::array with 400 x 400 in size. An unsigned byte is defined as uint8_t in C++, which we will use when we declare the array.</p> <pre><code>std::array&lt;uint8_t, 400 * 400&gt; buffer;\n</code></pre> <p>Now we need to move the file pointer to the correct position for reading the elevation values in the file. We seek 268 bytes starting from the beginning of the file.</p> <pre><code>infile.seekg(268, ios::beg);\n</code></pre> <p>Now we are in a position to be able to read the data. To read we use the .read() method, which takes a pointer to a buffer and the size of the buffer. The data in the std::array can be accessed by the .data()-method, but needs to be cast to the correct pointer type. We do this with the reinterpret_cast() function in C++. The size of the buffer is returned by the .size()-method. <pre><code>infile.read(reinterpret_cast&lt;char*&gt;(buffer.data()), buffer.size());\n\ninfile.close();\n</code></pre> <p>This is everything required to read all the data from the binary file into our std::array. To use the data we write it back to a text file storing the data separated by commas (CSV).</p> <p>To do this we open a output file stream.</p> <pre><code>fstream outfile;\noutfile.open(\"../data/colorado_elev.csv\", ios::out);\n\nif (!outfile.is_open())\n{\n    cout &lt;&lt; \"Error opening file\" &lt;&lt; endl;\n    return 1;\n}\n</code></pre> <p>Next we loop over the data in the file and write it to a text file with 400 values per row. To be able to write our uint8_t values we need to cast them to int. We do this with the static_cast() function. The final code is shown below: <pre><code>for (auto i = 0; i &lt; 400; i++)\n{\n    for (auto j = 0; j &lt; 400; j++)\n        outfile &lt;&lt; static_cast&lt;int&gt;(buffer[i * 400 + j]) &lt;&lt; \",\";\n    outfile &lt;&lt; \"\\n\";\n}\n\noutfile.close();\n</code></pre> <p>This file can be read and plotted in NumPy/Matplotlib with:</p> <pre><code># Load data\ndata = np.genfromtxt('colorado_elev.csv', delimiter=',')\n\n# Plot\nplt.figure()\nplt.contourf(data) \nplt.title('Colorado')\nplt.savefig('colorado.png')\n</code></pre> <p>The resulting image is shown below:</p> Data from binary file."},{"location":"language/","title":"The C++ Language","text":"<p>This chapter will go through the language elements of C++. To understand the language we will start with the fundamentals and transition to more modern features as we continue through this book. </p>"},{"location":"language/#example-of-c-code","title":"Example of C++ code","text":"<p>An example of a simple C++ program is shown in the following example.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    for (auto i = 0; i &lt; 10; i++)\n        cout &lt;&lt; i &lt;&lt; \"\\n\";\n\n    cout &lt;&lt; \"Hello, C++\\n\";\n}\n</code></pre> <pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nHello, C++\n</code></pre> <p>The example starts by including the iostream header, which provide means to output text in the terminal. The using namespace std statement just tells the compiler that the default namespace for the C++ standard library, std, will be used as the default, making it possible to omit the std::-prefix in front of all functions and objects. Namespaces will be covered later in the course.</p> <p>int main() is the C++ main function, which will be called when the application starts. It is sometimes also called the application entry point.</p> <p>cout is a special predefined object in C++ that can be used to output text and variables to the terminal. The &lt;&lt;-operator is used to send data to the cout object which will be sent to standard output for display in the terminal.</p>"},{"location":"language/#variables","title":"Variables","text":"<p>Variables are references to data stored in memory and give you a way of referencing the data using a name instead of an address. Care should be given when assigning variable names so that they are self-explanatory.  </p> <p>A naming convention that is often used in C++ is CamelCase. In this convention, names are formed by combining multiple words into single names, capitalizing the first letter of each word. Variables start with a lower case letter. Class names are all upper case. Examples can be:</p> <pre><code>class EquationSolver; // Classes are nouns. Start with upper case.\ndouble length;        // variables start with lower case.\nint totalNumber;      // variable with two words with camel case.\nvoid myFunction();    // Functions and methods lower case CamelCase.\n</code></pre>"},{"location":"language/#variable-names","title":"Variable names","text":"<p>The C++ language also defines some rules regarding variable naming. Variables in C++ should consist of:</p> <ul> <li>Letters a-z, A-Z (not \u00c5, \u00c4, \u00d6) </li> <li>Numbers 0-9 </li> <li>Underscore _ </li> <li>First character must be a letter or an underscore.</li> <li>Lower case letters are not equivalent with upper case letters. Case sensitive language.</li> </ul> <p>The following variable names are correct:</p> <pre><code>int i, j;\ndouble x, y;\ndouble z0;\nbool correct_answer;\n</code></pre> <p>The following variable names are not correct:</p> <pre><code>int 0i;\ndouble \u00e50;\n</code></pre>"},{"location":"language/#declaring-variables","title":"Declaring variables","text":"<p>C++ is a strongly type language and all variables needs to be declared with a type. A variable is declared by specifying the type followed by the variable name as shown in the following example:</p> <pre><code>int a;\ndouble c;\nfloat x;\n</code></pre> <p>In this example, an integer variable a, a double variable c and a float variable x is declared. </p> <p>Note</p> <p>Values of declared undefined until they have been initialized.  </p>"},{"location":"language/#variable-initialisation","title":"Variable initialisation","text":"<p>Before a variable is used it should be initialized, that is given a value. There are 2 ways of initialising a variable in C++. As C++ inherits a lot from C, variables can be initialised just like in C by assigning a value when the variable is declared using the equal (=) operator. In the following example we initialise variables at the same time as they are created using C style initialisation.</p> <pre><code>int i = 0;\nfloat x = 0.0;\n</code></pre> <p>Another way of initializing variables is using constructor-based initialization, which is specific to the C++ language. In this method, the variable is initialized by specifying the initial value in parenthesis:</p> <pre><code>int i(0);\nfloat x(0.0);\n</code></pre> <p>The final way of initializing values is using uniform initialization. This is also specific to the C++ language and uses curly brackets to assign initial values to variables. </p> <pre><code>int i{0};\nfloat x{0.0};\n</code></pre> <p>It is also possible to leave out the value of the initialisation. This initialises the variable to its default value.</p> <pre><code>int i{};\nfloat x{};\n</code></pre> <p>All these ways of initializing variables are equivalent. You will see some different ways of initializing variables in this book. Which type of initialization is chosen depends on the situation. In certain situations, one method can be more efficient than others. In other cases the code can be more readable using a certain example.</p>"},{"location":"language/#variable-types","title":"Variable types","text":"<p>In C++ there are 7 fundamental datatypes that can be used. </p> <ul> <li>Character types - char, char16_t, char32_t, wchar_t</li> <li>Signed integer types - short, int, long, long long</li> <li>Unsigned integer type - unsigned short, unsigned int, unsigned long, unsigned long long.</li> <li>Floating point types - float, double, long double</li> <li>Boolean type - bool</li> <li>void type - void</li> <li>nullptr - decltype(nullptr)</li> </ul> <p>Sizes of variables types depend on platform and compiler. C++ only specifies sizes relative to other types with at least number of bits.</p> <p>In the following chapters we will cover these datatypes in more details.</p>"},{"location":"language/#integer-types","title":"Integer types","text":"<p>Integer datatypes come in two flavors signed and unsigned. The basic signed integer type is int, which corresponds to signed int. The corresponding unsigned variable type is unsigned int. Unsigned variables always require the prefix unsigned. The available datatypes with increasing size:</p> <ul> <li>signed char / unsigned char</li> <li>short int / unsigned short int</li> <li>int / unsigned int </li> <li>long int / unsigned long</li> </ul> <p>Note</p> <p>Don't use unsigned to prevent negative values. This can lead to conversion errors later on.</p> <p>Unsigned integers can be used to represent bit patterns.</p> <p>The following code shows how different integer types are delcared and assigned. Please note what happens if you assign a negative value to an unsigned integer.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a;\n    unsigned int b;\n    long int c;\n    unsigned long int d;\n\n    a = -1;\n    b = -1; // What happens here?\n    c = -1;\n    d = -1; // and here?\n\n    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl;\n    cout &lt;&lt; \"d = \" &lt;&lt; d &lt;&lt; endl;\n}\n</code></pre> <pre><code>a = -1\nb = 4294967295\nc = -1\nd = 18446744073709551615\n</code></pre> <p>The size of an integer depends on the compiler and platform. C++ just provides relative guarantees between the different datatypes. The actual size of a datatype can be queried using the std::sizeof() function. This function returns the size in multiples of sizeof(char)=1. The relationship between the integer datatypes are:</p> <p>1 = sizeof(char) \u2264 sizeof(short) \u2264 sizeof(int) \u2264 sizeof(long)</p> <p>In the code below the std::sizeof() to query the exact size of the datatypes on the current platform.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a;\n    unsigned int b;\n    long int c;\n    unsigned long int d;\n\n    a = -1; b = -1;\n    c = -1; d = -1;\n\n    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \", sizeof(a) = \" &lt;&lt; sizeof(a) &lt;&lt; endl;\n    cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; \", sizeof(b) = \" &lt;&lt; sizeof(b) &lt;&lt; endl;\n    cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; \", sizeof(c) = \" &lt;&lt; sizeof(c) &lt;&lt; endl;\n    cout &lt;&lt; \"d = \" &lt;&lt; d &lt;&lt; \", sizeof(d) = \" &lt;&lt; sizeof(d) &lt;&lt; endl;\n}\n</code></pre> <pre><code>a = -1, sizeof(a) = 4\nb = 4294967295, sizeof(b) = 4\nc = -1, sizeof(c) = 8\nd = 18446744073709551615, sizeof(d) = 8\n</code></pre>"},{"location":"language/#character-types","title":"Character types","text":"<p>Character types contain values that correspond to the values from a character set. Character sets are guaranteed to contain numeric characters, 26 letters of the english alphabet and common delimiters. The smallest character type is char, which should be at least 8 bits (0..255). This can vary from different systems. The default type, char, is unsigned. There is also a signed version (-128..127). To support additional character sets there are alos additional character types:</p> <ul> <li>char16_t - at least 16 bits</li> <li>char32_t - at least 32 bits</li> <li>wchar_t - supporting the largest character set</li> </ul> <p>It is possible to convert from char to integer using the int() function.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    char c;\n    unsigned char uc;\n    signed char sc;\n    char16_t c16;\n    char32_t c32;\n    wchar_t w32;\n\n    c = 'a';\n    uc = 170;\n    sc = 130;\n\n    c16 = 'b';\n    c32 = 'c';\n    w32 = 'd';\n\n    cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; \" int(c) = \" &lt;&lt; int(c);\n    cout &lt;&lt; \" sizeof(c) = \" &lt;&lt; sizeof(c) &lt;&lt; endl;\n    cout &lt;&lt; \"uc = \" &lt;&lt; uc &lt;&lt; \" int(uc) = \" &lt;&lt; int(uc);\n    cout &lt;&lt; \" sizeof(c) = \" &lt;&lt; sizeof(c) &lt;&lt; endl;\n    cout &lt;&lt; \"sc = \" &lt;&lt; sc &lt;&lt; \" int(sc) = \" &lt;&lt; int(sc);\n    cout &lt;&lt; \" sizeof(c) = \" &lt;&lt; sizeof(c) &lt;&lt; endl;\n    wcout &lt;&lt; \"c16 = \" &lt;&lt; wchar_t(c16) &lt;&lt; \" int(c16) = \" &lt;&lt; int(c16);\n    cout &lt;&lt; \" sizeof(c16) = \" &lt;&lt; sizeof(c16) &lt;&lt; endl;\n    wcout &lt;&lt; \"c32 = \" &lt;&lt; wchar_t(c32) &lt;&lt; \" int(c32) = \" &lt;&lt; int(c32);\n    cout &lt;&lt; \" sizeof(c32) = \" &lt;&lt; sizeof(c16) &lt;&lt; endl;\n    wcout &lt;&lt; \"w32 = \" &lt;&lt; wchar_t(w32) &lt;&lt; \" int(w32) = \" &lt;&lt; int(w32);\n    cout &lt;&lt; \" sizeof(w32) = \" &lt;&lt; sizeof(w32) &lt;&lt; endl;\n}\n</code></pre> <pre><code>c = a int(c) = 97 sizeof(c) = 1\nuc = \u00aa int(uc) = 170 sizeof(c) = 1\nsc = \u201a int(sc) = -126 sizeof(c) = 1\nc16 = b int(c16) = 98 sizeof(c16) = 2\nc32 = c int(c32) = 99 sizeof(c32) = 2\nw32 = d int(w32) = 100 sizeof(w32) = 2\n</code></pre> <p>Note</p> <p>cout does not support unicode characters or char16_t or char32_t, which requires us to use the wcout operator instead and make a conversion to wchar_t instead.</p>"},{"location":"language/#floating-point-types","title":"Floating point types","text":"<p>Floating point datatypes are the essential buildingblocks of compuational codes. C++ support 3 floating point types:</p> <ul> <li>float - single precision</li> <li>double - double precision. Higher precision than float.</li> <li>long double - extended precision. Higher precision that double.</li> </ul> <p>If your computational relies on precision use double. The actual size of the types is compiler dependent. Usually the long double can be inefficient as this datatype is often not implemented in the processor architecture and the compiler will have to generate special CPU code for working with this datatype.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    double pi = 4 * std::atan(1);\n\n    float f;\n    double d;\n    long double ld;\n\n    f = pi;\n    d = pi;\n    ld = pi;\n\n    cout &lt;&lt; setprecision(15) &lt;&lt; \"f = \" &lt;&lt; f &lt;&lt; endl;\n    cout &lt;&lt; setprecision(15) &lt;&lt; \"d = \" &lt;&lt; d &lt;&lt; endl;\n    cout &lt;&lt; setprecision(15) &lt;&lt; \"ld = \" &lt;&lt; ld &lt;&lt; endl;\n}\n</code></pre> <pre><code>f = 3.14159274101257\nd = 3.14159265358979\nld = 3.14159265358979\n</code></pre>"},{"location":"language/#floating-point-literals","title":"Floating point literals","text":"<p>When assigning values to variables in C++ in can sometimes be required/benficial to specify the datatype of the scalar value specified in the source code (floating point literal). This can be done using suffixes on the value in the code. If no suffix is given on a value the datatype is assumed to be double. The following example illustrates the use of suffixes when specifying floating point literals: </p> <pre><code>float a = 1.0f;       // 1.0f is float\ndouble b = 1.0;       // 1.0 is assumed to be double\nlong double c = 1.0l; // 1.0l is long double\n</code></pre> <p>It is also possible to use literals with suffixes for literals in scientific notation:</p> <pre><code>float d = 1e300f;          // float\ndouble e = 1e-300;         // double\nlong double f = 42.0e-40l; // long double\n</code></pre>"},{"location":"language/#numerical-limits","title":"Numerical limits","text":"<p>To query the capabilites of datatypes, C++ provides functions for this in the  include file. Using the functions in this module it is possible to query max and min ranges for any standard data types. To query the largest value of a datatype use the std::numeric_limits&lt;[datatype]&gt;::max() function. In the same way query the lowest value using the std::numeric_limits&lt;[datatype]&gt;::min() function. It is also possible to check if a datatype is signed using the std::numeric_limits&lt;[datatype]&gt;::is_signed flag. The follwing example show how the functions are used: CodeOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nusing namespace std;\n\nint main()\n{\n    cout &lt;&lt; \"Max, char \" &lt;&lt; int(std::numeric_limits&lt;char&gt;::max()) &lt;&lt; endl;\n    cout &lt;&lt; \"Min, char \" &lt;&lt; int(std::numeric_limits&lt;char&gt;::min()) &lt;&lt; endl;\n    cout &lt;&lt; \"Is char signed \" &lt;&lt; std::numeric_limits&lt;char&gt;::is_signed &lt;&lt; endl;\n    cout &lt;&lt; \"Max, unsigned char \" &lt;&lt; int(std::numeric_limits&lt;unsigned char&gt;::max()) &lt;&lt; endl;\n    cout &lt;&lt; \"Min, unsigned char \" &lt;&lt; int(std::numeric_limits&lt;unsigned char&gt;::min()) &lt;&lt; endl;\n    cout &lt;&lt; \"Max, short \" &lt;&lt; std::numeric_limits&lt;short&gt;::max() &lt;&lt; endl;\n    cout &lt;&lt; \"Min, short \" &lt;&lt; std::numeric_limits&lt;short&gt;::min() &lt;&lt; endl;\n    cout &lt;&lt; \"Max, int \" &lt;&lt; std::numeric_limits&lt;int&gt;::max() &lt;&lt; endl;\n    cout &lt;&lt; \"Min, int \" &lt;&lt; std::numeric_limits&lt;int&gt;::min() &lt;&lt; endl;\n    cout &lt;&lt; \"Max, long \" &lt;&lt; std::numeric_limits&lt;long&gt;::max() &lt;&lt; endl;\n    cout &lt;&lt; \"Min, long \" &lt;&lt; std::numeric_limits&lt;long&gt;::min() &lt;&lt; endl;\n    cout &lt;&lt; \"Max, float \" &lt;&lt; std::numeric_limits&lt;float&gt;::max() &lt;&lt; endl;\n    cout &lt;&lt; \"Min, float \" &lt;&lt; std::numeric_limits&lt;float&gt;::min() &lt;&lt; endl;\n    cout &lt;&lt; \"Max, double \" &lt;&lt; std::numeric_limits&lt;double&gt;::max() &lt;&lt; endl;\n    cout &lt;&lt; \"Min, double \" &lt;&lt; std::numeric_limits&lt;double&gt;::min() &lt;&lt; endl;\n    cout &lt;&lt; \"Max, long double \" &lt;&lt; std::numeric_limits&lt;long double&gt;::max() &lt;&lt; endl;\n    cout &lt;&lt; \"Min, long double \" &lt;&lt; std::numeric_limits&lt;long double&gt;::min() &lt;&lt; endl;\n}\n</code></pre> <pre><code>Max, char 127\nMin, char -128\nIs char signed 1\nMax, unsigned char 255\nMin, unsigned char 0\nMax, short 32767\nMin, short -32768\nMax, int 2147483647\nMin, int -2147483648\nMax, long 9223372036854775807\nMin, long -9223372036854775808\nMax, float 3.40282e+38\nMin, float 1.17549e-38\nMax, double 1.79769e+308\nMin, double 2.22507e-308\nMax, long double 1.18973e+4932\nMin, long double 3.3621e-4932\n</code></pre>"},{"location":"language/#enumeration-types","title":"Enumeration types","text":"<p>Another important datatype in C++ is the enumeration type. Enumerations are similar to integers, but only have a limited set of predefined constants that can be assigned to an enumeration variable. Enumeration constant can also map to integer values. Which integer value that is mapped to a constant is determined by the order in which the constants are defined. It is also possible to assign specific values to the constants if that is desired. Enumerations can also be defined as distinct datatypes. If used in integer expressions they are converted to integers.</p> <p>A simple enumeration is shown in the following example:</p> <pre><code>enum { Low, Medium, High };\n\nint level = Medium;\n</code></pre> <p>We can also define an enumeration as a datatype in a similar way:</p> <pre><code>enum Level { Low, Medium, High };\n\nLevel level = Medium;\n</code></pre> <p>As said before enum constants can be assigned specific integer values as well:</p> <pre><code>enum Level { Low = -1, Medium = 0, High = 1 };\n\nLevel level = Medium;\n</code></pre> <p>A more complete example of how to use enums is shown below:</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    enum { Red, Green, Blue, Yellow };\n\n    cout &lt;&lt; \"RED = \" &lt;&lt; Red &lt;&lt; endl;\n    cout &lt;&lt; \"GREEN = \" &lt;&lt; Green &lt;&lt; endl;\n    cout &lt;&lt; \"BLUE = \" &lt;&lt; Blue &lt;&lt; endl;\n    cout &lt;&lt; \"YELLOW = \" &lt;&lt; Yellow &lt;&lt; endl;\n\n    int simple_color = Green;\n\n    cout &lt;&lt; \"simple_color = \" &lt;&lt; simple_color &lt;&lt; endl;\n\n    enum flavor { Vanilla, Chocolate, Orange, Strawberry };\n\n    flavor selectedFlavor = Orange;\n\n    cout &lt;&lt; \"selectedFlavor = \" &lt;&lt; selectedFlavor &lt;&lt; endl;\n\n    enum status { Finished = 0, Error = 15 };\n\n    status currentStatus = Error;\n\n    cout &lt;&lt; \"currentStatus = \" &lt;&lt; currentStatus &lt;&lt; endl;\n}\n</code></pre> <pre><code>RED = 0\nGREEN = 1\nBLUE = 2\nYELLOW = 3\nselectedFlavor = 2\ncurrentStatus = 15\n</code></pre>"},{"location":"language/#class-enumerations","title":"Class enumerations","text":"<p>The standard enum type in C++ can be error-prone due to its direct mapping to integers. In C++ 11 the enum class was introduced to solve these problems. Enum class names are local to the enum and can't be converted implicitly to other datatypes. Also, a name in a standard enum can't be reused in the same scope.</p> <p>A class enum is declared with the enum class keyword. The name must also be specified using the enum class name as a prefix, as shown below:</p> <pre><code>enum class Fruit = { Banana, Orange, Apple };\n\nFruit selectedFruit = Fruit::Banana;\n</code></pre> <p>A complete example is shown below.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    enum class Color\n    {\n        Grey,\n        Cyan,\n        Purple\n    };\n\n    Color color = Color::Cyan;\n\n    if (color == Color::Cyan)\n        cout &lt;&lt; \"Color is Cyan\" &lt;&lt; endl;\n    else\n        cout &lt;&lt; \"Color is not Cyan\" &lt;&lt; endl;\n}\n</code></pre> <pre><code>Color is Cyan\n</code></pre>"},{"location":"language/#arrays","title":"Arrays","text":"<p>Arrays are collections of elements with a shared datatype. Elements in the array are accessed using an index 0 ... n-1, where n is the size of the array. Indices are given in brackets. A simple array is declared as follows:</p> <pre><code>int a[10];\n</code></pre> <p>In this example an array, a, with 10 integer elements is declared. A value in the array can be accessed by specifying an index in a bracket as shown in the following code:</p> <pre><code>cout &lt;&lt; a[4] &lt;&lt; endl;\n</code></pre> <p>Here the value in position 5 of the array is printed on the screen. </p> <p>Accessing an array outside its defined range can lead to undefined behavior and ultimately crash the program.</p> <p>An array can be initialised with values using initialiser lists or by direct assignment of values specifying its index. Initialiser assignment is shown below:</p> <pre><code>a = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n</code></pre> <p>Direct assignment using indices is shown below:</p> <pre><code>for (int i=0; i&lt;10; i++)\n    a[i] = i;\n</code></pre> <p>Values of an unassigned array is considered to be undefined and can contain any values that corresponds to the values in the memory location of the variable.</p> <p>If an array is initialised with a initialiser list, the size of the array can be omitted.</p> <pre><code>int c[] = { 7, 6, 5, 4, 3, 2, 1 }; // equivalent to int c[7]\n</code></pre> <p>Multidimensional arrays can also be created by specifying 2 or more dimensions when declaring the array:</p> <pre><code>int b[2][2] = { { 1, 2 }, { 3, 4 } };\n</code></pre> <p>Note</p> <p>Contigous multidimensional arrays are not directly supported in C++. It however possible to create a similar datatype using some tricks, but this is covered in later sections.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a[2];\n\n    a[0] = 1;\n    a[1] = 2;\n\n    cout &lt;&lt; a[0] &lt;&lt; \", \" &lt;&lt; a[1] &lt;&lt; endl;\n\n    double b[] = { 1.0, 2.0, 3.0, 4.0 };\n    b[3] = 42.0;\n\n    cout &lt;&lt; b[0] &lt;&lt; \", \" &lt;&lt; b[1] &lt;&lt; \", \" &lt;&lt; b[2] &lt;&lt; \", \" &lt;&lt; b[3] &lt;&lt; endl;\n\n    int c[2][2] = { { 1, 2 }, { 3, 4 } };\n\n    cout &lt;&lt; c[0][0] &lt;&lt; \", \" &lt;&lt; c[0][1] &lt;&lt; endl;\n    cout &lt;&lt; c[1][0] &lt;&lt; \", \" &lt;&lt; c[1][1] &lt;&lt; endl;\n}\n</code></pre> <pre><code>1, 2\n1, 2, 3, 42\n</code></pre>"},{"location":"language/#c-strings","title":"C Strings","text":"<p>As C++ is a superset of C it supports the creation of C based strings. A C string is very similar to an array and is declared in the same way:</p> <p>char name[size]</p> <p>Size is the number of characters the string can have. It is important that strings in C are terminated with a null character #0 or \"\\n\". You should always declare a string length with one more the required length.</p> <p>Intialising C strings can be done either directly at creation or using an assignment later in the code.</p> <p>The easiest assignment is when declaring the variable:</p> <pre><code>char myString[] = \"This is my string.\";\n</code></pre> <p>Just like arrays we don't have to specify the size if the variable is initialised directly. When initialising like this an null character is automatically added. It is also possible to declare a string with a specified length.</p> <pre><code>char myString[50] = \"This is my string.\";\n</code></pre> <p>Here storage space for 50 characters is allocated and initialised with a predefined string. This string can now be reassigned strings up to 50 characters.</p> <p>For international support there are also additional character types available in the standard such as char16_t, char32_t and wchar_t which has been mentioned before. </p> <p>We will not go too deep into C strings as C++ has a built-in string type, std::string, which is much easier and safer to use.</p>"},{"location":"language/#pointers","title":"Pointers","text":"<p>Pointers are variables that store memory references to locations in memory. Pointer in C++ can be both typed and untyped. A pointer variable is declared with a star operator (*). The syntax for a pointer declaration is:</p> <p>[datatype]* name;</p> <p>The following code shows a typical pointer declaration:</p> <pre><code>int* a;\n</code></pre> <p>a is pointer to a memory location containing an integer.</p> <p>To get a pointer to a non-pointer variable the &amp; operator can be used. In  the following example we assigne the memory location of b to the pointer variable a.</p> <pre><code>int* a;\nint b;\n\na = &amp;b; // a now points to the memory location of b\n</code></pre> <p>If we want to get the value of the memory location the pointer variable references we can use the star (*) operator dereference the pointer.</p> <pre><code>int* a;\nint b = 42;\n\na = &amp;b;\n\ncout &lt;&lt; *a &lt;&lt; \"\\n\"; // Dereferencing pointer a,\n                    // Displaying the value a points to\n</code></pre> <p>In this example the value of a is printed, which actually is value of b.</p> <p>In C++ we can also declare an untyped pointer using the void datatype. This pointer can be assigned any typed pointer. However assigning a non-typed pointer to a typed pointer requires a type cast. </p> <pre><code>int* a;\nint b = 42;\nvoid* c;\n\na = &amp;b;\nc = a;  // OK assigning a typed pointer to a non-typed.\n\na = static_cast&lt;int*&gt;(c); // Assigning a non-typed pointer to \n                          // an typed pointer requires a cast.\n</code></pre> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a{42};\n    int* b;\n    void* c;\n\n    b = &amp;a; // Assigning the address of a to pointer b\n    c = b;  // Assigning the pointer b to the non-typed pointer c\n\n    // To assign a non-typed pointer to a typed pointer we need\n    // to cast the c pointer to an int* pointer\n\n    b = static_cast&lt;int*&gt;(c);\n\n    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"*b = \" &lt;&lt; *b &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; \"\\n\";\n}\n</code></pre> <pre><code>a = 42\nb = 0x291bfffb4c\n&amp;a = 0x291bfffb4c\n*b = 42\nc = 0x291bfffb4c\n</code></pre> <p>The following figures illustrate how pointers are assigned in the previous code example:</p> Assigning pointer b with the &amp; operator \\*b is the value stored at memory location b"},{"location":"language/#array-pointer-duality","title":"Array pointer duality","text":"<p>Arrays and pointers are very closely related in C++. Pointer types can be accessed using array notation and arrays can be accessed with pointers. This enables both flexibility as well as increasing the risk for errors. The concept is best illustrated with an example.</p> <p>First we declare an array a with some values.</p> <pre><code>int a[] = {0, 1, 2, 3};\n</code></pre> <p>Next we declare a pointer variable b.</p> <pre><code>int* b;\n</code></pre> <p>An array variable can be directly assigned to a pointer variable of the same datatype like this:</p> <pre><code>b = a;\n</code></pre> <p>The pointer variable b now points to the first element of the a array. If we print out these variables we get:</p> <pre><code>cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \"\\n\";\ncout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; \"\\n\";\n</code></pre> <pre><code>a = 0x7fff5fbff6a0\nb = 0x7fff5fbff6a0\n</code></pre> <p>Both the array a and the pointer variable b point to the same address. Also, a when printing does not print the array but the memory address. This is the C++ array/pointer duality.</p> <p>Both a and b can accessed using array notation. Printing a[0] and b[0] should give the same values.</p> <pre><code>cout &lt;&lt; \"a[0] = \" &lt;&lt; a[0] &lt;&lt; \"\\n\";\ncout &lt;&lt; \"b[0] = \" &lt;&lt; b[0] &lt;&lt; \"\\n\";\n</code></pre> <pre><code>a[0] = 0\nb[0] = 0\n</code></pre> <p>So array and pointer declarations are equivalent except that an is allocated a memory location for the provided values.</p> <p>It is also possible to get a pointer to a specific element of an array using a combination of the &amp; operator and array notation.</p> <pre><code>int* c;\n\nc = &amp;a[2];\n</code></pre> <p>c now stores a pointer to the third value of the a array. We can also use some pointer arithmetic to do the same thing by using the + operator on a pointer variable.</p> <pre><code>int* d;\n\nd = b + 2;\n</code></pre> <p>d now points to a location 2 integers from the memory location of b. c and b points to the same locations.</p> <pre><code>c = &amp;a[2];\n\ncout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; \"\\n\";\ncout &lt;&lt; \"*c = \" &lt;&lt; *c &lt;&lt; \"\\n\";\n\nd = b + 2;\n\ncout &lt;&lt; \"d = \" &lt;&lt; d &lt;&lt; \"\\n\";\ncout &lt;&lt; \"*d = \" &lt;&lt; *d &lt;&lt; \"\\n\";\n</code></pre> <pre><code>c = 0x156bdff8a8\n*c = 2\nd = 0x156bdff8a8\n*d = 2\n</code></pre> <p>Pointer variables can be modified using the ++, --, + and - operators. Increments are done in multiples of the size of the actual datatype. </p> <p>Note</p> <p>It is important to make sure that the location a pointer variable references is a valid memory location. Dereferencing a memory location that has not been allocated memory often leads to crashes and undefined behavior.</p> <p>Below is the complete example in this section.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a[] = {0, 1, 2, 3};\n    int* b;\n    int* c;\n    int* d;\n\n    b = a;\n\n    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"a[0] = \" &lt;&lt; a[0] &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"b[0] = \" &lt;&lt; b[0] &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"*b = \" &lt;&lt; *b &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"*a = \" &lt;&lt; *a &lt;&lt; \"\\n\";\n\n    c = &amp;a[2];\n\n    cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"*c = \" &lt;&lt; *c &lt;&lt; \"\\n\";\n\n    d = b + 2;\n\n    cout &lt;&lt; \"d = \" &lt;&lt; d &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"*d = \" &lt;&lt; *d &lt;&lt; \"\\n\";\n}\n</code></pre> <pre><code>a = 0x7fff5fbff6a0\nb = 0x7fff5fbff6a0\na[0] = 0\nb[0] = 0\n*b = 0\n*a = 0\nc = 0x7fff5fbff6a8\n*c = 2\n</code></pre> Pointer operations in the previous example."},{"location":"language/#references","title":"References","text":"<p>References are alternative names for variables of the same data type. It is mainly used for return parameters in functions, but can also be used as variables. A reference variable defined by using the &amp; operator after the datatype declaration. The syntax is:</p> <p>[data type]&amp; name</p> <p>A reference variable must be initialised and can't be declared without an initialisation. The following code shows an example of how a reference variable can be declared.</p> <pre><code>int a = 42;\nint&amp; b = a;\n</code></pre> <p>In this code b is a reference to a and can be used just like the a variable.</p> <p>We will look more on this when declaring functions.</p> <p>A complete example on how references are used is shown below:</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a = 42;\n    int&amp; b = a;\n\n    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; endl;\n    cout &lt;&lt; \"&amp;b = \" &lt;&lt; &amp;b &lt;&lt; endl;\n}\n</code></pre> <pre><code>a = 42\nb = 42\n&amp;a = 0x7fff5fbff6bc\n&amp;b = 0x7fff5fbff6bc\n</code></pre>"},{"location":"language/#constants","title":"Constants","text":"<p>Constants can be seen as read-only variables that can't be changed during program execution. Can be used to replace numeric constants in the source code, making code more easily updatable by placing these values in a single place. </p> <p>Constants can also be used to precompute expressions at compile time, preventing it to be calculated at run-time, to save computations. </p> <p>A constant is declared with the const keyword with the following syntax:</p> <p>const [datatype] name = value</p> <p>An example of this can be:</p> <pre><code>const int v = 42;\n</code></pre> <p>This declares a constant v with the value 42.</p> <p>In later versions of C++ the notion of constants have been expanded, so that the compiler can execute functions and generate code at compile time using the constexpr-keyword. </p> <p>A complete example of how to use constants is given below:</p> Code <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int max_size = 4;\n\nint main()\n{\n    int a[max_size];\n\n    for (int i=0; i&lt;max_size; i++)\n        a[i] = 0;\n}\n</code></pre>"},{"location":"language/#structured-data-types","title":"Structured data types","text":"<p>In many application it can be beneficial to combine several datatypes into a custom data type. In C++ this can be achieved using the struct datatype. In a struct a set of fields of different datatypes can be combined into a structured datatype. I it similar to a records in a database. In the followin code a number of fields are combined into an Employee struct.</p> <pre><code>struct Employee {\n    char[15] firstName;\n    char[15] lastName;\n    char[30] address;\n}\n</code></pre> <p>The defined Employee struct can now be declared and used like any other datatype in C++. A svea Employee variable is declared </p> <pre><code>Employee svea;\n</code></pre> <p>To assign values to the inner records dot-notation can be used.</p> <pre><code>svea.firstName = \"Svea\";\nsvea.lastName = \"Svensson\";\nsvea.address = \"Unknown\";\n</code></pre> <p>It is also possible to create arrays of structs.</p> <pre><code>Employee employees[10];\n</code></pre> <p>Access to the individual records is done using the following code:</p> <pre><code>employee[0].firstName = \"Fredrik\";\n</code></pre> <p>If the Employee variable is dynamically allocated individual records needs to be accessed using the -&gt; operator.</p> <pre><code>svea-&gt;firstName = \"Dynamo\";\n</code></pre> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    struct coord3D {\n        double x{};\n        double y{};\n    };\n\n    coord3D c1;\n    coord3D c2;\n\n    c1.x = 0.0;\n    c1.y = 0.0;\n    c2.x = 1.0;\n    c2.y = 1.0;\n\n    cout &lt;&lt; \"c1.x = \" &lt;&lt; c1.x &lt;&lt; \", c1.y = \" &lt;&lt; c1.y &lt;&lt; endl;\n    cout &lt;&lt; \"c2.x = \" &lt;&lt; c2.x &lt;&lt; \", c2.y = \" &lt;&lt; c2.y &lt;&lt; endl;\n    cout &lt;&lt; \"sizeof(c1) = \" &lt;&lt; sizeof(c1) &lt;&lt; endl;\n}\n</code></pre> <pre><code>c1.x = 0, c1.y = 0\nc2.x = 1, c2.y = 1\nsizeof(c1) = 16\n</code></pre>"},{"location":"language/#type-deduction-and-the-auto-keyword","title":"Type deduction and the auto keyword","text":"<p>In C++ all variables must be declared with a type, which can lead to long declarations and make the code unreadable. In many cases, the compiler can automatically deduce which data type should be used. In those cases, we can use the auto keyword to tell the compiler to figure out the data type for us automatically. Consider the following example:</p> <pre><code>int a = 42;\n</code></pre> <p>A string literal in C++ (a constant value in the source code) is represented by the data type it fits, starting with int followed by long int and long long int. In the above example fits in a int variable and is stored as an int the compiled code. If we are not interested in the actual data type we can let the compiler decide the statement above then becomes:</p> <pre><code>auto a = 42;\n</code></pre> <p>We can validate using the  include in the standard library using the following code. <pre><code>cout &lt;&lt; typeid(a).name() &lt;&lt; endl;\n</code></pre> <p>This will print out</p> <pre><code>i\n</code></pre> <p>i is GCC:s type name for an int. Other variable declarations can also be deduced by the string literal assigned to the auto declared variable.</p> <pre><code>auto b = 42l;   // type suffix for a long data type\nauto c = 42.0;  // no suffix denotes a double\nauto d = 42.0f; // f suffix denotes a float\n\ncout &lt;&lt; typeid(b).name() &lt;&lt; endl;\ncout &lt;&lt; typeid(c).name() &lt;&lt; endl;\ncout &lt;&lt; typeid(d).name() &lt;&lt; endl;\n</code></pre> <p>Which gives the following output:</p> <pre><code>l\nd\nf\n</code></pre> <p>The complete example is given below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nusing namespace std;\n\nint main()\n{\n    auto a = 42;    // By default int\n    auto b = 42l;   // suffix defines a long\n    auto c = 42.0;  // By default a double\n    auto d = 42.0f; // suffix denotes a float\n\n    cout &lt;&lt; typeid(a).name() &lt;&lt; endl;\n    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;\n    cout &lt;&lt; typeid(c).name() &lt;&lt; endl;\n    cout &lt;&lt; typeid(d).name() &lt;&lt; endl;\n}\n</code></pre> <pre><code>i\nl\nd\nf    \n</code></pre> <p> Try example</p> <p>A good use of the auto keyword is to use it as the data type for loop variables. The compiler will then automatically select the correct data type depending on the size of the loop range. An auto declared loop is shown in the following example:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nusing namespace std;\n\nint main()\n{\n    for (auto i=99999999; i&lt;100000000; i++)\n        cout &lt;&lt; i &lt;&lt; \", \" &lt;&lt; typeid(i).name() &lt;&lt; endl;\n}\n</code></pre> <pre><code>99999999, i\n</code></pre> <p> Try example</p> <p>Increase the range of the loop in the example and see how the datatype changes.</p> <p>The auto keyword becomes more interesting when working with data structures and algorithm by reducing the complexity of the required declarations.</p>"},{"location":"language/#strings","title":"Strings","text":"<p>To overcome many of the limitations of the C based string, C++ provides its own string type, std::string. This is a very flexible string type that also provides more safety. The string type also provides compatibility with the C string by providing a special method for passing it as character string using the .c_str() method.</p> <p>To use the C++ string type we need to add the following include:</p> <pre><code>#include &lt;string&gt;\n</code></pre> <p>A std::string is declared just like any normal C++ datatype.</p> <pre><code>std::string s1 = \"My first string.\";\nstd::string s2{\"My second string.\"};\n</code></pre> <p>A more complete example is given below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s = \"hello\";\n    cout &lt;&lt; \"a = '\" &lt;&lt; s &lt;&lt; \"'\" &lt;&lt; endl;\n}\n</code></pre> <pre><code>a = 'hello'\n</code></pre> <p>Note</p> <p><code>std::string</code> is the real variable type as it is part of the :<code>std</code> namespace. </p>"},{"location":"language/#string-operations","title":"String operations","text":"<p>The benefits of using std::string is how you can use it with standard C++ operators to create new strings.</p> <pre><code>std::string s1 = \"C++\";\nstd::string s2 = \"is\";\nstd::string s3 = \"fun\";\nstd::string fun = s1 + \" \" + s2 + \" \" + s3;\n</code></pre> <p>In the above example 3 strings are combined together to a new string, fun, which is automatically resized to the size of all strings and spaces.</p> <p>The length of a string can be queried using the .length() method.</p> <pre><code>cout &lt;&lt; fun.lentgth() &lt;&lt; \"\\n\"; // Prints the string length\n</code></pre> <p>Individual string characters can be accessed using the bracket operator or using the .at() method.</p> <pre><code>cout &lt;&lt; fun[0] &lt;&lt; \"\\n\";    // Prints first character\ncout &lt;&lt; fun.at(1) &lt;&lt; \"\\n\"; // Prints second character\n</code></pre> <p>The following example illustrates more string operations.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s1 = \"hello\";\n    string s2 = \", world\";\n    string s3 = s1 + s2;\n    cout &lt;&lt; \"s3 = '\" &lt;&lt; s3 &lt;&lt; \"'\" &lt;&lt; endl;\n    cout &lt;&lt; \"s3.length() = \" &lt;&lt; s3.length() &lt;&lt; endl;\n    cout &lt;&lt; \"s3[7] = \" &lt;&lt; s3[7] &lt;&lt; endl;\n    cout &lt;&lt; \"s3.at(7) = \" &lt;&lt; s3.at(7) &lt;&lt; endl;\n}\n</code></pre> <pre><code>s3 = 'hello, world'\ns3.length() = 12\ns3[7] = w\ns3.at(7) = w\n</code></pre>"},{"location":"language/#c-string-methods","title":"C++ String methods","text":"<p>std::string is an class that has many methods for interacting with the string. The .length() method was mentioned in previous sections, but there are many more methods available. The .append(string)-method appends a string to an existing string. Corresponds to the + operator. It is also possible to use .replace(pos, n, string)-method to replace n characters at position pos with string. The .insert(pos, string)-method inserts string at position pos in the string. Finally the .substr(pos, n)-method extract n characters from position pos.</p> <p>In the following example these methods are illustrated.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s1 = \"hello\";\n    string s2 = \", world\";\n    string s3 = s1 + s2;\n\n    s3.append(\". Strings in C++ are great!\");\n    cout &lt;&lt; \"s3 = \" &lt;&lt; s3 &lt;&lt; endl;\n\n    s3.replace(33, 6, \"nice! \");\n    cout &lt;&lt; \"s3 = \" &lt;&lt; s3 &lt;&lt; endl;\n\n    s3.insert(33, \"great and \");\n    cout &lt;&lt; \"s3 = \" &lt;&lt; s3 &lt;&lt; endl;\n\n    string s4 = s3.substr(33, 6);\n    cout &lt;&lt; \"s4 = \" &lt;&lt; s4 &lt;&lt; endl;\n\n}\n</code></pre> <pre><code>s3 = hello, world. Strings in C++ are great!\ns3 = hello, world. Strings in C++ are nice! \ns3 = hello, world. Strings in C++ are great and nice! \ns4 = great \n</code></pre> <p> Try example</p>"},{"location":"language/#searching-c-strings","title":"Searching C++ strings","text":"<p>A very common tasks when using string is searching for specific characters or substrings in a string. In std::string the .find()-method can be used for this purpose. The first version of this method .find(string) finds the first occurrence of string and returns the position in the string. In the second version of this method .find(string, startpos) the search is performed from the startpos position and the next occurrence is returned. If string is not found the method returns std::string::npos. The use of this method is shown in the following example:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s = \"The quick brown fox jumps over the lazy dog.\";\n\n    auto p0 = s.find(\"o\");\n    auto p1 = s.find(\"o\", p0+1);\n    auto p2 = s.find(\"xx\");\n\n    cout &lt;&lt; \"The first 'o' is at position \" &lt;&lt; p0 &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"The next 'o' is at position \" &lt;&lt; p1 &lt;&lt; \"\\n\";\n\n    if (p2 == string::npos)\n        cout &lt;&lt; \"xx was not found.\\n\";\n    else\n        cout &lt;&lt; \"xx was found.\\n\";\n}\n</code></pre> <pre><code>The first 'o' is at position 12\nThe next 'o' is at position 17\n</code></pre> <p> Try example </p>"},{"location":"language/#compatibility-with-c-strings-char","title":"Compatibility with C strings (char*)","text":"<p>In many cases, it is required to interface with existing C code or call APIs that require a C-based string (char*). A std::string is not directly compatible with a C-string, but can be easily interfaced with them. A std::string can be assigned a C-string directly as shown in the following example:</p> <pre><code>char cstr[] = \"This is a C-string\";\nstd::string s = cstr;\n</code></pre> <p>The opposite is not directly possible. However, std::string provides a special method, .c_str(), that return a C-string (char*) that can be used to copy it to a C-string or given to a call to a function that requires it. In the following example we create a C++ string which we copy to a C-string using the strcpy() function which is available in the <code>#include &lt;cstring&gt;</code> header.</p> <pre><code>string s = \"This is a C++ string.\";\nchar cstr[255] = \"\";\nstrcpy(cstr, s.c_str());\n</code></pre> <p>A more complete example of the use of .c_str() is given below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nint main()\n{\n    const char* cString;\n    char cString2[128];\n\n    string cppString = \"Hello, world!\";\n\n    cString = cppString.c_str();\n\n    cout &lt;&lt; \"cString = \" &lt;&lt; cString &lt;&lt; endl;\n#ifndef WIN32\n    strncpy(cString2, cppString.c_str(), cppString.length()+1);\n#else\n    strncpy_s(cString2, cppString.c_str(), cppString.length()+1);\n#endif\n    cout &lt;&lt; \"cString2 = \" &lt;&lt; cString2 &lt;&lt; endl;\n}\n</code></pre> <pre><code>cString = Hello, world!\ncString2 = Hello, world!\n</code></pre> <p>Note</p> <p>Allow for an extra position for the #0 character in the <code>strncpy</code> call.  </p> <p>Note</p> <p><code>strncpy</code> is a overflow safe version of the C <code>strcpy</code> function. </p>"},{"location":"language/#expressions-and-operators","title":"Expressions and operators","text":"<p>In C++ expressions can be created using the many available operators. For the basic data types in C++ the operators work just like in any other language. Operators can also be used with other datatypes, however, the operations can be quite different from those defined for the basic data types. The order of precedence is as follows:</p> <ol> <li>Increment operators a++, a--</li> <li>Increment operators ++a, --a</li> <li>Unary sign operators +a, -a</li> <li>Multiplication a * b</li> <li>Division a / b</li> <li>Modulus a % b</li> <li>Addition a + b </li> <li>Subtraction a - b</li> </ol>"},{"location":"language/#arithmetic-operators","title":"Arithmetic operators","text":"<p>The arithmetic operators are defined in the following table in order of precedence:</p> Operator Description (+/-)x Unary sign operator * Multiplication / Division % Modulo + Addition - Subtraction"},{"location":"language/#relational-operators","title":"Relational operators","text":"<p>Relational operators are used to compare different variables or values. They return either true or false. They are typically used in if-statements or similar, which are described in the following sections.</p> Operator Meaning Python &lt; less than &lt; &lt; less than or equal &lt;= == equal == != not equal != &gt;= greater than or equal &gt;="},{"location":"language/#logical-operators","title":"Logical operators","text":"<p>Logical operators are used for logical comparisons of boolean expressions. The operators take either true or false as input and return either true or false. They are also typically used in if*-statements or similar, which are described in the following sections.</p> Operator Meaning Python &amp;&amp; and and || or or ! not not"},{"location":"language/#compound-assignment-operators","title":"Compound assignment operators","text":"<p>Compound assignment operators simplify some operations to reduce the complexity of an expression as well as increase efficiency.</p> Operator Description Equivalent to += a += b a = a + b -= a -= b a = a - b /= a /= b a = a / b *= a *= b a = a * b %= a %= b a = a % b <p>The following code shows the usage of a compound assignment operator.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a, b;\n\n    a = 42;\n    b = 26;\n\n    a += b; // a = a + b\n\n    cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;\n}\n</code></pre> <pre><code>a = 68\n</code></pre>"},{"location":"language/#increment-and-decrement-operators-","title":"Increment and decrement operators (++/--)","text":"<p>A common operation on basic data types is to increment or decrement a variable by 1. C++ defines special increment (++) and decrement (--) operators for this purpoose. The operators exist in 2 versions, a prefix (++a/--a) and a postfix (a++/a--) version. The difference is that the prefix version will return the updated value when evaluated in an expression. The postfix version will return the existing value when evaluated in an expression.</p> <p>In the following example, b, will be assigned the value of a after it has been updated by the increment operator, giving it the value of 43. c will be assigned the value of a before it is updated by the increment operator, giving it the value of 43. The final value of a will be 44.</p> CodeOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int a, b, c;\n\n    a = 42;\n\n    b = ++a;\n    c = a++;\n\n    cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl;\n}\n</code></pre> <pre><code>b = 43\nc = 43\n</code></pre>"},{"location":"language/#conditional-operator","title":"Conditional operator ?","text":"<p>There is also a special operator that can return different values depending on a given condition. The syntax is as follows:</p> <p>condition ? result_if_true : result_if_false</p> <p>If condition is true the result of the expression will be result_if_true otherwise result_if_false. </p> <p>Warning</p> <p>This operator should be used with caution as it can lead to code that is difficult to read.</p> <p>The following example shows how the operator can be used. The user is asked for a number, number. The outValue variable is assigned 42 if number is greater than or equal to 50 otherwise it is assigned 21.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int number;\n\n    cout &lt;&lt; \"Enter a number : \";\n\n    cin &gt;&gt; number;\n\n    int outValue = (number&gt;50) ? 42 : 21;\n\n    cout &lt;&lt; \"outValue = \" &lt;&lt; outValue;\n}\n</code></pre> <pre><code>Enter a number : 45\noutValue = 21\n\nEnter a number : 55\noutValue = 42\n</code></pre>"},{"location":"language/#expressions","title":"Expressions","text":"<p>To illustrate the precedence rules the following example</p> <pre><code>-a + b + c1\n</code></pre> <p>is evaluated from left to right as.</p> <pre><code>((-a) + b) + c\n</code></pre> <p>The expression </p> <pre><code>-a + b * c \n</code></pre> <p>is evaluates from left to right as</p> <pre><code>(-a) + (b * c)\n</code></pre> <p>Note</p> <p>If uncertain it is never wrong to add a parenthesis. </p> <p>Note</p> <p>If functions are used in expressions they are evaluated before any other operators.</p>"},{"location":"language/#mixed-mode-expressions","title":"Mixed-mode expressions","text":"<p>If expressions are constructed with operands of many different datatypes, weaker datatypes are coerced to the stronger one. Results will be of the stronger type. This is illustrated in the following example where the i integer variable is coerced to double.</p> <pre><code>double a;\nint i;\ndouble b;\n\nb = a * i // i is coerced to double_types1\n</code></pre>"},{"location":"language/#statements-and-code-structure","title":"Statements and code structure","text":"<p>Code in C++ consists of statements that form the code of an application or a library. There are two types of statements in C++, normal statements separated by semicolons (;) and compound statements grouped with curly brackets { }. The below code consists of normal statements:</p> <pre><code>int a = 42;    // statement 1\nint b = 21;    // statement 2\nint c = a + b; // statement 3\n</code></pre> <p>Compound statements or code blocks are mostly used in function/class definitions, conditional expressions and iteration structures. All variables declared in a compound statement will be automatically removed when execution exits the statement. The following code illustrates this:</p> <pre><code>int main()\n{\n    int a = 0;     // normal statement\n\n    // compound statement\n\n    {              \n        int b = 1;\n        int c = 2;\n    }\n\n    int d = b;     // Error, b is not available here    \n}\n</code></pre> <p>Standalone compound statements can be used to force the automatic cleanup of variables and dereference shared pointers, which is described later in this book. However, their main use is to define the structure of your application by defining functions and logical statements of the application.</p> <p>In the following sections, we will go through the basic building blocks that define the behavior of your code.</p>"},{"location":"language/#control-structures","title":"Control structures","text":"<p>Control structures are constructs that control the flow of your application. It can be constructs for iterating code, taking different routes depending on the state of variables (branching) or defining reusable parts of code (functions). </p>"},{"location":"language/#iteration","title":"Iteration","text":"<p>One of the more important control structures is for repeating some code several times or until a specific condition is met (iteration). There are 3 major iteration statements in C++</p> <ul> <li>while \u2013 Condition before iteration statements</li> <li>do \u2013 Condition after iteration statements</li> <li>for \u2013 Compact version of the while-statement</li> </ul> <p>All iterations statements are controlled using the same methods. The break-statement can be used to exit an iteration statement. The continue-statement can be used to continue to the next iteration. A return-statement will also exit a loop, but also a function. The exit()-statement will also terminal a loop and the entire application.</p> <p>The following example uses a for-statement to illustrate the use of break and continue to control the flow in an iteration statement.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    for (auto i=0; i&lt;20; i++)\n    {\n        if (i==6)\n            continue;\n\n        if (i==10)\n            break;\n\n        cout &lt;&lt; i &lt;&lt; \"\\n\";\n    }\n}    \n</code></pre> <pre><code>0\n1\n2\n3\n4\n5\n7\n8\n9\n</code></pre> <p>In line 10 the iteration will continue and no output will be printed. In line 13 the iteration will stop and the for-loop exited.</p> <p>Try it yourself below:</p> <p> Try example </p>"},{"location":"language/#while-statement","title":"while-statement","text":"<p>The while-statement iterates a statement until a certain expression is false. In the folowing code we defined the variable counter, which we initalise to 0. We will use counter in the expression in the while-statement. In the example we will loop until counter is less than or equal to 10. In the code block for the while-statement the value of the counter is printed and increased by 1. </p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() \n{\n    int counter = 1;\n\n    while (counter &lt;= 10) \n    {\n        cout &lt;&lt; \"counter = \" &lt;&lt; counter &lt;&lt; endl;\n        counter = counter + 1;\n    }\n}\n</code></pre> <pre><code>counter = 1\ncounter = 2\ncounter = 3\ncounter = 4\ncounter = 5\ncounter = 7\ncounter = 8\ncounter = 9\ncounter = 10\n</code></pre> <p>Note</p> <p>In a while-statement it is our responsibility to make sure any variables used in the expression are initialised. If not the code can get stuck in an endless iteration. The same situation can happen if the variables in the expression are not updated in the code block for the while-statement.</p> <p> Try example </p>"},{"location":"language/#do-statement","title":"do-statement","text":"<p>In the while-statement the statements in the code block are not executed if the expression evaluated to false. If the statements should be executed at least once, the do-statement can be used instead. In this construct the conditional expression is evaluated after the the first iteration.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() \n{\n    int counter = 1;\n\n    do\n    {\n        cout &lt;&lt; \"counter = \" &lt;&lt; counter &lt;&lt; endl;\n        counter = counter + 1;\n    }\n    while (counter&lt;=10);\n}\n</code></pre> <pre><code>counter = 1\ncounter = 2\ncounter = 3\ncounter = 4\ncounter = 5\ncounter = 7\ncounter = 8\ncounter = 9\ncounter = 10\n</code></pre> <p>In this example counter is initalised and the first iteration of the do-statement is entered regardless of the value of the counter variable. If counter would have been set to 20, the value would still have been printed in the first iteration.</p> <p> Try example </p>"},{"location":"language/#for-statement","title":"for-statement","text":"<p>To create a shorter version of the do/while-statements which also can initialise and update a loop variable we can use the for-statement instead. The syntax of this statement is as follows:</p> <p>for([start statements]; [conditional expression]; [step statements])       statements</p> <p>The start expression is executed before the iteration. conditional expression is evaluated to determine if the iteration should continue. step statements is executed after each iteration. A typical for-statement is shown below:</p> <pre><code>for (int i=0; i&lt;10; i++)\n    cout &lt;&lt; i &lt;&lt; \"\\n\";\n</code></pre> <p>In this loop i is initialised to 0 before the iteration. The iteration continues if i is less than 10. On every iteration i is incremented by 1.</p> <p>If we want to iterate starting from one we can use the following for-statement instead: </p> <pre><code>for (int i=1; i&lt;=10; i++)\n    cout &lt;&lt; i &lt;&lt; \"\\n\";\n</code></pre> <p>Using the for-statement makes it unnessecary to declare a special loop variable outside the iteration statement and creates a single statement containing initalisation, conditional expression and loop variable update.</p> <p>Note</p> <p>The loop variable declared in the for-statement is not available outside the code block of the loop. </p> <p>The parameters in the for-statement are not required. If give an empty parameters we get an endless loop as in the following example:</p> <p><pre><code>for (;;)\n{\n    // endless loop\n}\n</code></pre> An example of using a for-statement to update the counter as in the previous examples is shown</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    for (auto counter = 1; counter&lt;=10; counter++)\n        cout &lt;&lt; \"counter = \" &lt;&lt; counter &lt;&lt; endl;\n}\n</code></pre> <pre><code>counter = 1\ncounter = 2\ncounter = 3\ncounter = 4\ncounter = 5\ncounter = 7\ncounter = 8\ncounter = 9\ncounter = 10\n</code></pre> <p> Try example </p> <p>In the following example, we use the iteration update step to calculate a sum.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    auto sum = 0;\n\n    for (auto i=0; i&lt;=10000; sum += ++i);\n\n    cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl;\n}\n</code></pre> <pre><code>sum = 50015001\n</code></pre> <p> Try example </p>"},{"location":"language/#conditional-statements","title":"Conditional statements","text":"<p>There are 2 main conditional statements in C++, the if-statement and the switch-statement. The if-statement takes single or multiple conditions as input and executes the code block if the conditions evaluate to true. It is also possible to add a code block that is executed when the condition is false. This is done by adding an else-section to the if-statement.</p> <p>The switch-statement is used to select multiple paths depending on the condition.</p>"},{"location":"language/#if-statement","title":"if-statement","text":"<p>The if-statement in its simplest form has the following syntax:</p> <pre><code>if (condition) statement\n</code></pre> <p>or</p> <pre><code>if (condition)\n    statement\nelse\n    statement\n</code></pre> <p>if condition returns true statement is executed. An example of this is shown below:</p> <pre><code>if (answer==42) cout &lt;&lt; \"The answer was 42.\\n\";\n</code></pre> <p>It is also possible to use else to execute statements if the condition is false as in the following example:</p> <pre><code>if (answer==42)\n    cout &lt;&lt; \"The answer was 42.\\n\";\nelse\n    cout &lt;&lt; \"The answer was not 42.\\n\";\n</code></pre> <p>Note</p> <p>No semicolon (;) is required after else as this belongs to the if-statement.</p> <p>If more statements are required to be executed a code block can be added to the if-statement as shown in the following example:</p> <pre><code>if (answer&gt;42)\n{\n    cout &lt;&lt; \"The answer was greater than 42.\\n\";\n    cout &lt;&lt; \"This requires a more thorough explanation.\\n\";\n}\nelse\n{\n    cout &lt;&lt; \"The answer could have been 42. You never know?\\n\";\n}\n</code></pre> <p>Multiple conditions can be combined using relational and logical operators. It is important to use parenthesis to separate the relational and logical operations. In the following example we use an if-statement to determine if x is inside a certain interval.</p> <pre><code>if ((x&gt;=-1.0)&amp;&amp;(x&lt;1.0))\n    cout &lt;&lt; \"x is in the interval -1.0 &lt;= x &lt; 1.0\\n\";\n</code></pre> <p>In the following example, we use an if-statement to output when the loop counter, i, is 5.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    for (int i=1; i&lt;=10; i++)\n    {\n        cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl;\n\n        if (i==5)\n            cout &lt;&lt; \"i == 5\" &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>i = 1\ni = 2\ni = 3\ni = 4\ni = 5\ni == 5\ni = 6\ni = 7\ni = 8\ni = 9\ni = 10\n</code></pre> <p>In this example, the else statement is used.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    for (int i=1; i&lt;=10; i++)\n    {\n        if (i==5)\n            cout &lt;&lt; \"i == 5\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; \"i != 5\" &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>i != 5\ni != 5\ni != 5\ni != 5\ni != 5\ni == 5\ni != 5\ni != 5\ni != 5\ni != 5\ni != 5\n</code></pre> <p>In this example, we use a nested for-statement.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    for (int i=1; i&lt;=10; i++)\n    {\n        cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \": \";\n\n        if (i==5)\n            cout &lt;&lt; \"i == 5\" &lt;&lt; endl;\n        else if ( (i&gt;=2)&amp;&amp;(i&lt;=3) )\n            cout &lt;&lt; \"2 &lt;= i &lt;= 3\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; \"-\" &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>i = 1: -\ni = 2: 2 &lt;= i &lt;= 3\ni = 3: 2 &lt;= i &lt;= 3\ni = 4: -\ni = 5: i == 5\ni = 6: -\ni = 7: -\ni = 8: -\ni = 9: -\ni = 10: -\n</code></pre>"},{"location":"language/#switch-statement","title":"switch-statement","text":"<p>A switch-statement is suitable when a lot of options needs to be evaluated from a single expression. The syntax is:</p> <pre><code>switch (condition)\n{\n    case expression: \n        statement\n\n    default:\n        statement\n}\n</code></pre> <p>If the condition evaluates to one of the case expressions, code jumps to this case expression. Execution then continues through the following case expressions. If conditions does not evaluate to any of the case expressions execution continues after the switch-statement or executes the code in the default label. The following code shows an example of this:</p> <pre><code>switch (state) \n{\n    case 0:\n        cout &lt;&lt; \"state = 0\\n\";\n    case 1: \n        cout &lt;&lt; \"state = 1\\n\";\n    default:\n        cout &lt;&lt; \"state is not 0 or 1\\n\";\n}\n</code></pre> <p>If state is 0 output will be:</p> <pre><code>state = 0\nstate = 1\nstate is not 0 or 1\n</code></pre> <p>if state is 1 code execution jumps to the case 1: label and the output will be:</p> <pre><code>state = 1\nstate is not 0 or 1\n</code></pre> <p>If state is not any of the case expressions the default section will be executed producing the output:</p> <pre><code>state is not 0 or 1\n</code></pre> <p>If we only want one of the case expressions to be evaluated for a given state we have to add a break after each case expression as in the following code:</p> <pre><code>switch (state) \n{\n    case 0:\n        cout &lt;&lt; \"state = 0\\n\";\n        break;\n    case 1: \n        cout &lt;&lt; \"state = 1\\n\";\n        break;\n    default:\n        cout &lt;&lt; \"state is not 0 or 1\\n\";\n        break;\n}\n</code></pre> <p>The break statement will exit the switch-statement. The above code with state set to 0 will produce the following output:</p> <pre><code>state = 0\n</code></pre> <p>switch-statements are very suitable when comparing enumerations as the following example illustrates:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nint main()\n{\n    enum colorType { RED, GREEN, BLUE, YELLOW, ORANGE };\n    srand((unsigned)time(0));\n\n\n    for (int i=0; i&lt;4; i++)\n    {\n        colorType color = colorType(rand()%5);\n        switch (color)\n        {\n            case RED:\n                cout &lt;&lt; \"Color is red.\" &lt;&lt; endl;\n                break;\n            case GREEN:\n                cout &lt;&lt; \"Color is green.\" &lt;&lt; endl;\n                break;\n            default:\n                cout &lt;&lt; \"Color is either BLUE, YELLOW or ORANGE.\" &lt;&lt; endl;\n                break;\n        }\n    }\n}\n</code></pre> <pre><code>Color is green.\nColor is either BLUE, YELLOW or ORANGE.\nColor is either BLUE, YELLOW or ORANGE.\nColor is red.\n</code></pre>"},{"location":"language/#functions","title":"Functions","text":"<p>Functions are the main building blocks of your code. A function is a named block of code performing a certain task of your application. A function can have input arguments and optionally also return a value. The simplified syntax of a function is:</p> <pre><code>[return type] [name]([arguments])\n{\n    statements\n}\n</code></pre> <p>If the function does not return anything the void data type must be given. Arguments to the function are also optional. No arguments are indicated with an empty parenthesis. A very simple funtion with no return value and no arguments then becomes:</p> <pre><code>void simple_func()\n{\n    cout &lt;&lt; \"This function just prints this message...\\n\";\n}\n</code></pre> <p>The return value is returned using the return-statement as shown in this function:</p> <pre><code>int meaning_of_life()\n{\n    return 42;\n}\n</code></pre> <p>Calling a function that doesn't return a value is done by simply giving the name of the function and its argument (empty for the above functions) list:</p> <pre><code>simple_func()\n</code></pre> <p>To call a function that returns a value we must declare a variable to receive the returned value:</p> <pre><code>int meaning{0};\n\nmeaning = meaning_of_life();\n</code></pre> <p>Alternatively we can declare and assign the value in a single statement:</p> <pre><code>int meaning = meaning_of_life();\n</code></pre> <p>Variables declared in the function code block are local to the function and are not available outside the function.</p> <p>The following example shows how a function is declared and called from a main program.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid simple()\n{\n    cout &lt;&lt; \"Hello, from function!\" &lt;&lt; endl;\n}\n\nint main()\n{\n    simple();\n}\n</code></pre> <pre><code>Hello, from function!\n</code></pre>"},{"location":"language/#function-arguments","title":"Function arguments","text":"<p>The function arguments are a way of giving input as well as receiving output from a function. By default all values to a function are passed by value, that is the value of an argument is copied over to the function. Passing by value also means that the input argument can't change anything in the code calling the function.</p> <p>Function arguments are declared in the parenthesis of the function using the datatype of the argument and the name of the argument. Multiple arguments can be specified separating them with commas. Below is a simple function with a single integer argument:</p> <pre><code>void myfunc(int a)\n{\n    cout &lt;&lt; a &lt;&lt; \"\\n\";\n}\n</code></pre> <p>The function just prints out the value of a. It is possible to use the argument as a variable in the function code block.</p> <pre><code>void myfunc(int a)\n{\n    cout &lt;&lt; a &lt;&lt; \"\\n\";\n    a = 42;\n    cout &lt;&lt; a &lt;&lt; \"\\n\";\n}\n</code></pre> <p>As the argument a is passed by value the assignment of a in the function will not affect the any variables in the code calling the function. A complete example of a function with an argument called from a main program is shown below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid simple(int a)\n{\n    cout &lt;&lt; \"The value of a = \" &lt;&lt; a &lt;&lt; endl;\n}\n\nint main()\n{\n    simple(42);\n}\n</code></pre> <pre><code>The value of a = 42\n</code></pre> <p>In the following example, this behavior is illustrated by printing the address of the variables in the main program as well as in the function using the reference operator (&amp;).</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid simple(int a)\n{\n    cout &lt;&lt; \"The value of a = \" &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; endl;\n}\n\nint main()\n{\n    int a = 42;\n    simple(a);\n\n    cout &lt;&lt; \"&amp;a = \" &lt;&lt; &amp;a &lt;&lt; endl;\n}\n</code></pre> <pre><code>The value of a = 42\n&amp;a = 0x7fff5fbff69c\n&amp;a = 0x7fff5fbff6bc\n</code></pre>"},{"location":"language/#passing-output-arguments","title":"Passing output arguments","text":"<p>In most functions we are also interested in getting data out from the function. This can be done in a couple of ways. One way is to pass a pointer over to the function. The pointer itself is passed by value, but the pointer itself points to the address of the variable that should receive the value. The assign a value to the incoming argument we need to dereference the pointer. In the following function we declare an integer pointer for the outgoing argument that we want the function to modify we use the star operator to dereference the pointer, so that we can assign the value of the variable passed in to the function:</p> <pre><code>void simple(int* a)\n{\n    cout &lt;&lt; \"The value of a = \" &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; \"*a = \" &lt;&lt; *a &lt;&lt; endl;\n    *a = 43;\n}\n</code></pre> <p>In the main program we declare the variable we want to pass to the function. We can't pass this variable directly to the function as the function requires a pointer as input. To solve this we use the reference operator (&amp;) to pass the address of a to the function:</p> <pre><code>int main()\n{\n    int a = 42;\n    simple(&amp;a);\n    cout &lt;&lt; \"The value of a = \" &lt;&lt; a &lt;&lt; endl;    \n}\n</code></pre> <p>Passing pointer gives us the ability to pass a variable into a function and let the function modify it's value. The complete example is shown below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid simple(int* a)\n{\n    cout &lt;&lt; \"The value of a = \" &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; \"*a = \" &lt;&lt; *a &lt;&lt; endl;\n}\n\nint main()\n{\n    int a = 42;\n    simple(&amp;a);\n}\n</code></pre> <pre><code>The value of a = 0x7fff5fbff6bc\n*a = 42\n</code></pre> <p>The syntax for scalar values using pointers is a bit clumsy to use. However, there is a better way using reference operators in the argument list. To do this we declare the arguments that will be modified by the function using the reference operator. The previous function then becomes:</p> <pre><code>void simple(int&amp; a)\n{\n    cout &lt;&lt; \"The value of a = \" &lt;&lt; a &lt;&lt; endl;    \n    a = 43;\n}\n</code></pre> <p>Using the reference operator in the declaration the variable can be used without a star operator just like any other variable. Assigning a value in the function will also change the variable in the code calling the function.</p> <pre><code>int main()\n{\n    int a = 42;\n    simple(a);\n    cout &lt;&lt; \"The value of a = \" &lt;&lt; a &lt;&lt; endl;    \n}\n</code></pre> <p>Running the above code will print out 43 as the function has assigned 43 to the reference variable a in the function.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid simple(int* a)\n{\n    *a = 43;\n}\n\nint main()\n{\n    int a = 42;\n\n    cout &lt;&lt; \"Before function call: a = \" &lt;&lt; a &lt;&lt; endl;\n    simple(&amp;a);\n    cout &lt;&lt; \"After function call : a = \" &lt;&lt; a &lt;&lt; endl;\n}\n</code></pre> <pre><code>Before function call: a = 42\nAfter function call : a = 43\n</code></pre>"},{"location":"language/#passing-arrays","title":"Passing arrays","text":"<p>Because there is a duality between pointer and arrays, it is possible to pass arrays using pointers or using the index operator. A function with an array as input can be defined as</p> <pre><code>void print_array(char* a)\n{\n    for (int i=0; i&lt;4; i++)\n        cout &lt;&lt; a[i] &lt;&lt; \", \";\n    cout &lt;&lt; endl    \n}\n</code></pre> <p>or </p> <pre><code>void print_array(char a[])\n{\n    for (int i=0; i&lt;4; i++)\n        cout &lt;&lt; a[i] &lt;&lt; \", \";\n    cout &lt;&lt; endl    \n}\n</code></pre> <p>The following example shows a complete example with both methods.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid print_array_1(int* a)\n{\n    for (int i=0; i&lt;4; i++)\n        cout &lt;&lt; a[i] &lt;&lt; \", \";\n    cout &lt;&lt; endl;\n}\n\nvoid print_array_2(int a[])\n{\n    for (int i=0; i&lt;4; i++)\n        cout &lt;&lt; a[i] &lt;&lt; \", \";\n    cout &lt;&lt; endl;\n}\n\nint main()\n{\n    int a[] = { 1, 2, 3, 4 };\n    print_array_1(a);\n    print_array_2(a);\n}\n</code></pre> <pre><code>1, 2, 3, 4, \n</code></pre> <p>It is also possible to modify the array in the function as shown below.</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid simple(int* a)\n{\n    a[3] = 42;\n}\n\nint main()\n{\n    int a[] = { 1, 2, 3, 4 };\n    simple(a);\n    cout &lt;&lt; \"a[3] = \" &lt;&lt; a[3] &lt;&lt; endl;\n}\n</code></pre> <pre><code>1, 2, 3, 4, \n</code></pre>"},{"location":"language/#preventing-accidental-modification-of-arguments-const","title":"Preventing accidental modification of arguments (const)","text":"<p>Passing by reference and pointers also means that they can be modified in the functions. If this is not desired it is possible to use the const modifier to tell the compiler that the function arguments are not allowed to be modified in the function. We still get the benefits of directly being able to access the incoming argument. In the following declaration we pass a float variable by reference, but prefix it with the const modifier. Trying to modify the variable in the function will give a compiler error.</p> <pre><code>float add(const float&amp; a, const float&amp; b)\n{\n    // a = 42; // Uncomment this line will generate a compiler error.\n    return a + b;\n}\n</code></pre> <p>Try this yourself in the following example:</p> <p> Try example</p> <p>Using const for basic types in C++ is not really required. It makes more sense when more complicated data types are used such as string, vectors and other classes. In the following example we pass 2 strings by reference to a function using the const modifier. This prevents them to be modified in the function. It is also more efficient to pass strings by reference as the string does not have to be copied.</p> <pre><code>void log_output(const std::string&amp; context, const std::string&amp; message)\n{\n    cout &lt;&lt; context &lt;&lt; \": \" &lt;&lt; message &lt;&lt; \"\\n\";\n}\n</code></pre> <p>Try this yourself in the following example:</p> <p> Try example</p> <p>const can also be used with arrays to prevent them to be accidentally modified in a function:</p> <pre><code>void print_array(const int* a)\n{\n    for (int i=0; i&lt;4; i++)\n        cout &lt;&lt; a[i] &lt;&lt; \", \";\n    cout &lt;&lt; endl    \n}\n</code></pre> <p>This is the array example from previous sections using the const modifier.</p> <p> Try example</p> <p>Note</p> <p>Consider declaring as many input arguments as possible using the const modifier. This prevents accidental modification of arguments as well as give important hints to the compiler so it can generate more efficient code.</p>"},{"location":"language/#memory-allocation","title":"Memory allocation","text":"<p>In C++, memory allocation can be broadly classified into two types: stack-based memory allocation and heap-based memory allocation. </p> <p>Stack-based memory allocation is automatic and is utilized for all local variables defined in the main program, functions, and code blocks. When a stack-based variable goes out of scope, meaning the execution leaves the corresponding code block, the memory occupied by that variable is automatically freed. The name \"stack\" comes from the way memory is managed for these variables - they are pushed onto the stack when defined in the code block and popped off the stack when the code block execution is completed.</p> <p>Note</p> <p>Please note that in stack-based memory allocation, the size of the memory allocated to a variable is fixed and determined at compile time. This means that the memory for variables is allocated and deallocated in a last-in, first-out (LIFO) manner, following the order of variable declaration and scope.</p> <p>The other kind of memory allocation is heap-based memory allocation. The heap is an area that is managed by the operating system and allocating memory on the heap requires a call to the operating system, which can be costly. However, in many cases the amount of memory required can't always be determined at compile time, then we have to use heap-based allocation. </p> <p>When we allocate on the heap we will receive a memory address from the operating system which we assign to a pointer variable. It is also important to note that it is the developer's responsibility to release allocated heap memory when it is not needed anymore. </p> <p>In the following sections, we will cover how memory on the heap is allocated using the builtin methods for this in C++</p>"},{"location":"language/#memory-allocation-in-c","title":"Memory allocation in C++","text":"<p>In C++ allocation on the heap is using the new operator. The new operator has the following syntax:</p> <pre><code>new type initialiser\n</code></pre> <p>new returns a pointer to the allocated type. In the following example we allocate a single floating point value.</p> <pre><code>float* pvalue = nullptr;\npvalue = new float;\n</code></pre> <p>To access and assign a value to the newly created memory we need to dereference the pointer.</p> <pre><code>*pvalue = 42.0f;\ncout &lt;&lt; *pvalue &lt;&lt; \"\\n\";\n</code></pre> <p>When we are done using the allocated memory we need to release it again to the operating system. If we don't release the memory we have created a memory leak in our program and if memory is allocated continuously during the lifetime of your application the application will at some point have consumed all memory in your computer, which can lead to crashes and your computer slowing down. To release memory allocated on the heap the delete operator is used. The syntax is:</p> <pre><code>delete pointer-variable;\n</code></pre> <p>To delete our previously allocated memory the code becomes.</p> <pre><code>delete pvalue;\n</code></pre> <p>The allocated memory has now been release back to the operating system. We will discuss in the coming chapters how we can avoid creating memory leaks by using smart pointers, that handle the deallocation of memory automatically.</p>"},{"location":"language/#allocating-arrays","title":"Allocating arrays","text":"<p>Allocating basic scalar types in C++ is overkill. The real benefits of heap memory allocation is to allocate large arrays of different datatypes. C++ has special versions of the new and delete functions for allocating arrays. </p> <p>To allocate an array in C++ we add a bracket with the size of the array when we allocate memory for the array.</p> <pre><code>float* arr = nullptr;\n\narr = new float[100];\n</code></pre> <p>or in a single statement.</p> <pre><code>float* arr = new float[100];\n</code></pre> <p>As pointers can be used using array notation by default an array created with new can doesn't have to be dereferenced as with the basic types. </p> <pre><code>for (int i=0; i&lt;100; i++)\n    arr[i] = 0.0f;\n</code></pre> <p>When the array is no longer needed it has to be released with delete. However, we need to use a special version of delete on arrays, delete [].</p> <pre><code>delete [] arr;\n</code></pre>"},{"location":"language/#two-dimensional-arrays-c-style","title":"Two-dimensional arrays C++ Style","text":"<p>C++ has no direct support for dynamically allocated two-dimensional arrays. However, we can create arrays of pointers to arrays to simulate this kind of an array. The idea is to create an array of pointers for each row in the array. These pointers will point to arrays with size of the number of columns of the array. First we declare our main array, which will contain rows pointers of int. These pointers we will allocated in the inner loop</p> <pre><code>const int rows = 4;\nconst int cols = 8;\n\nint** array = new int*[rows];\n</code></pre> <p>Next we loop over the main array, allocating an array for each row with the size cols.</p> <pre><code>for (auto i=0; i&lt;rows; i++)\n{\n    array[i] = new int[cols];\n\n    for (auto j=0; j&lt;cols; j++)\n        array[i][j] = 0;\n}\n</code></pre> <p>We now have an allocated two-dimensional array, which we can used like any other array in C++. Assigning the second row and second column can be done like this:</p> <pre><code>array[1][1] = 42;\n</code></pre> <p>To delete the allocated memory for this array we first need to delete the memory for our rows and finally delete the outer array of pointers.</p> <pre><code>// Deleting row arrays\n\nfor (auto i=0; i&lt;rows; i++)\n    delete [] array[i];\n\n// Delete main array.\n\ndelete [] array;\n</code></pre> <p>The best way of handling the creation and destruction of these arrays is to create one function for creating the array and another one for destroying the array, see following sections.</p> <p>A complete example of this is shown below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int rows = 4;\nconst int cols = 8;\n\nint main()\n{\n    int** array = new int*[rows];\n\n    int counter = 0;\n\n    for (auto i=0; i&lt;rows; i++)\n    {\n        array[i] = new int[cols];\n\n        for (auto j=0; j&lt;cols; j++)\n            array[i][j] = counter++;\n    }\n\n    for (auto i=0; i&lt;rows; i++)\n    {\n        for (auto j=0; j&lt;cols; j++)\n            cout &lt;&lt; array[i][j] &lt;&lt; \", \";\n\n        cout &lt;&lt; endl;\n    }\n\n    // Deleting row arrays\n\n    for (auto i=0; i&lt;rows; i++)\n        delete [] array[i];\n\n    // Delete main array.\n\n    delete [] array;\n}\n</code></pre> <pre><code>0, 1, 2, 3, 4, 5, 6, 7, \n8, 9, 10, 11, 12, 13, 14, 15, \n16, 17, 18, 19, 20, 21, 22, 23, \n24, 25, 26, 27, 28, 29, 30, 31, \n</code></pre> <p> Try example</p>"},{"location":"language/#two-dimensional-array-fortran-style","title":"Two-dimensional array Fortran Style","text":"<p>The method using an array of pointers is not a very efficient data structure in computational codes as it creates as it allocates many smaller memory blocks. To solve this we can use the same approach as in Fortran and allocate a single memory block and access it like a two-dimensional array with some tricks.</p> <p>First we create the same array of pointer as in the previous example.</p> <pre><code>int** array = new int*[rows];\n</code></pre> <p>We then allocate a single array that contains all elements of the array and assign the first pointer in array.</p> <pre><code>array[0] = new int[rows*cols];\n</code></pre> <p>To be able to access the array just like any other array we need to assign pointers to different positions in the array where the different rows start.</p> <pre><code>int counter = 0;\n\nfor (int i=0; i&lt;rows; i++)\n{\n    array[i] = &amp;array[0][i*cols];\n\n    for (int j=0; j&lt;cols; j++)\n        array[i][j] = counter++;\n}\n</code></pre> <p>The trick is on line 5. Here we retrieve the address (&amp;) where each row starts and assign it to the correct row of the pointer array. Destroying the array is done almost in the same way except we don't have to loop over the outer array.</p> <pre><code>delete [] array[0];\ndelete [] array;\n</code></pre> <p>A complete example is available below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int rows = 4;\nconst int cols = 8;\n\nint main()\n{\n    int** array = new int*[rows];\n    array[0] = new int[rows*cols];\n\n    int counter = 0;\n\n    for (int i=0; i&lt;rows; i++)\n    {\n        array[i] = &amp;array[0][i*cols];\n\n        for (int j=0; j&lt;cols; j++)\n            array[i][j] = counter++;\n    }\n\n    for (int i=0; i&lt;rows; i++)\n    {\n        for (int j=0; j&lt;cols; j++)\n            cout &lt;&lt; array[i][j] &lt;&lt; \", \";\n\n        cout &lt;&lt; endl;\n    }\n\n    delete [] array[0];\n    delete [] array;\n}\n</code></pre> <pre><code>0, 1, 2, 3, 4, 5, 6, 7, \n8, 9, 10, 11, 12, 13, 14, 15, \n16, 17, 18, 19, 20, 21, 22, 23, \n24, 25, 26, 27, 28, 29, 30, 31, \n</code></pre> <p> Try example</p>"},{"location":"language/#functions-for-2d-arrays","title":"Functions for 2D arrays","text":"<p>To make it easier to used two-dimensional arrays in C++ we will implement three functions for this purpose:</p> <ol> <li>A function for creating an array of a given size.</li> <li>A function for initialising the array with a given value.</li> <li>A function for destroying the allocated array.</li> </ol> <p>The function for creating an array will need to have an output argument for the allocated array (int**) and input argument for the number of rows and columns. We use the reference operator (&amp;) for passing the allocated pointer out from the function. The finished function becomes:</p> <pre><code>void createArray(int** &amp;array, int rows, int cols)\n{\n    array = new int*[rows];\n    array[0] = new int[rows*cols];    \n\n    for (auto i=0; i&lt;rows; i++)\n        array[i] = &amp;array[0][i*cols];\n}\n</code></pre> <p>The function does not initialise the values of the array. An example of this is shown in the following function:</p> <pre><code>void zeroArray(int** &amp;array, int rows, int cols)\n{\n    for (auto i=0; i&lt;rows; i++)\n        for (auto j=0; j&lt;cols; j++)\n            array[i][j] = 0;\n}\n</code></pre> <p>As we pass by reference array can be used just as if it was a normal variable.</p> <p>Finally implement a function for destroying the allocated array:</p> <pre><code>void deleteArray(int** &amp;array)\n{\n    delete[] array[0];\n    delete[] array;\n    array = nullptr;\n}\n</code></pre> <p>Note</p> <p>To enable checking if the array has been allocated or destroyed we assign the array the special value nullptr to indicate that the variable is destroyed.</p> <p>To use the functions we first declare our array and assign it the nullptr as value. </p> <pre><code>int** array = nullptr;\n</code></pre> <p>Next we call the createArray() function to allocate our array.</p> <pre><code>createArray(array, 4, 8);\n</code></pre> <p>Next, we initialize our array with zeros using the zeroArray() function.</p> <pre><code>zeroArray(array, 4, 8);\n</code></pre> <p>We can now use the array just like in our previous examples.</p> <pre><code>for (auto i=0; i&lt;4; i++)\n{\n    for (auto j=0; j&lt;8; j++)\n        cout &lt;&lt; array[i][j] &lt;&lt; \", \";\n\n    cout &lt;&lt; endl;\n}\n</code></pre> <p>Finally we destroy the array with:</p> <pre><code>deleteArray(array);\n</code></pre> <p>A complete example of this is shown below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid createArray(int** &amp;array, int rows, int cols)\n{\n    array = new int*[rows];\n    array[0] = new int[rows*cols];    \n\n    for (auto i=0; i&lt;rows; i++)\n        array[i] = &amp;array[0][i*cols];\n}\n\nvoid zeroArray(int** &amp;array, int rows, int cols)\n{\n    for (auto i=0; i&lt;rows; i++)\n        for (auto j=0; j&lt;cols; j++)\n            array[i][j] = 0;\n}\n\nvoid deleteArray(int** &amp;array)\n{\n    delete[] array[0];\n    delete[] array;\n    array = nullptr;\n}\n\nint main()\n{\n    int** array{nullptr};\n\n    createArray(array, 4, 8);\n    zeroArray(array, 4, 8);\n\n    for (auto i=0; i&lt;4; i++)\n    {\n        for (auto j=0; j&lt;8; j++)\n            cout &lt;&lt; array[i][j] &lt;&lt; \", \";\n\n        cout &lt;&lt; endl;\n    }\n\n    deleteArray(array);\n}\n</code></pre> <pre><code>0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, \n0, 0, 0, 0, 0, 0, 0, 0, \n</code></pre> <p> Try example</p>"},{"location":"language/#dynamic-arrays-of-struct","title":"Dynamic arrays of struct","text":"<p>Just as it is possible to create arrays of the basic variable types it is also possible to create arrays of defined datatypes with the struct datatype. In principle it is done mostly just like normal arrays. In the following example we will define a struct, coord3D, for storing the position of a coordinate in space.</p> <pre><code>struct coord3D {\n    double x;\n    double y;\n    double z;\n};\n</code></pre> <p>Next, we allocate an array of 10 coordinates.</p> <pre><code>coord3D* coords = new coord3D[10];\n</code></pre> <p>We can now use the array to initialise the coordinates. Accessing the individual elements of the coord3D struct is done using dot notation as shown in the code below.</p> <pre><code>double counter = 0.0;\n\nfor (auto i=0; i&lt;10; i++)\n{\n    coords[i].x = counter++;\n    coords[i].y = counter++;\n    coords[i].z = counter++;\n}\n</code></pre> <p>Printing the values is done in a similar way.</p> <pre><code>for (auto i=0; i&lt;10; i++)\n    cout &lt;&lt; coords[i].x &lt;&lt; \", \" &lt;&lt; coords[i].y &lt;&lt; \", \" &lt;&lt; coords[i].z &lt;&lt; endl;\n</code></pre> <p>As this is a dynamically allocated array we need to delete it using the delete [] statement.</p> <pre><code>delete [] coords;\n</code></pre> <p>The complete example can found below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct coord3D {\n    double x;\n    double y;\n    double z;\n};\n\nint main()\n{\n    coord3D* coords = new coord3D[10];\n\n    double counter = 0.0;\n\n    for (auto i=0; i&lt;10; i++)\n    {\n        coords[i].x = counter++;\n        coords[i].y = counter++;\n        coords[i].z = counter++;\n    }\n\n    for (auto i=0; i&lt;10; i++)\n        cout &lt;&lt; coords[i].x &lt;&lt; \", \" &lt;&lt; coords[i].y &lt;&lt; \", \" &lt;&lt; coords[i].z &lt;&lt; endl;\n\n    delete [] coords;\n}\n</code></pre> <pre><code>0, 1, 2\n3, 4, 5\n6, 7, 8\n9, 10, 11\n12, 13, 14\n15, 16, 17\n18, 19, 20\n21, 22, 23\n24, 25, 26\n27, 28, 29\n</code></pre> <p> Try example</p>"},{"location":"language/#dynamic-arrays-of-struct-pointers","title":"Dynamic arrays of struct pointers","text":"<p>In some cases it can be required to allocate the individual structs themself dynamically. To do this we allocate an array of pointers to the struct.</p> <pre><code>coord3D** coords = new coord3D*[10];\n</code></pre> <p>Before we can use this array we need to initialise the pointers of the array. In this case we need to allocate each element of the array using a new statement.</p> <pre><code>double counter = 0.0;\n\nfor (auto i=0; i&lt;10; i++)\n{\n    coords[i] = new coord3D;\n    coords[i]-&gt;x = counter++;\n    coords[i]-&gt;y = counter++;\n    coords[i]-&gt;z = counter++;\n}\n</code></pre> <p>Accessing the individual element of the struct must now be done using the arrow operator (-&gt;). </p> <pre><code>for (auto i=0; i&lt;10; i++)\n    cout &lt;&lt; coords[i]-&gt;x &lt;&lt; \", \" &lt;&lt; coords[i]-&gt;y &lt;&lt; \", \" &lt;&lt; coords[i]-&gt;z &lt;&lt; endl;\n</code></pre> <p>To delete the array the individual structs must be deleted before we delete the outer pointer array.</p> <pre><code>for (auto i=0; i&lt;10; i++)\n    delete coords[i];\n</code></pre> <p>Finally the pointer array is deleted.</p> <pre><code>delete [] coords;\n</code></pre> <p>The complete example is shown below:</p> ExampleOutput <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct coord3D {\n    double x;\n    double y;\n    double z;\n};\n\nint main()\n{\n    coord3D** coords = new coord3D*[10];\n\n    double counter = 0.0;\n\n    for (auto i=0; i&lt;10; i++)\n    {\n        coords[i] = new coord3D;\n        coords[i]-&gt;x = counter++;\n        coords[i]-&gt;y = counter++;\n        coords[i]-&gt;z = counter++;\n    }\n\n    for (auto i=0; i&lt;10; i++)\n        cout &lt;&lt; coords[i]-&gt;x &lt;&lt; \", \" &lt;&lt; coords[i]-&gt;y &lt;&lt; \", \" &lt;&lt; coords[i]-&gt;z &lt;&lt; endl;\n\n    for (auto i=0; i&lt;10; i++)\n        delete coords[i];\n\n    delete [] coords;\n}\n</code></pre> <pre><code>0, 1, 2\n3, 4, 5\n6, 7, 8\n9, 10, 11\n12, 13, 14\n15, 16, 17\n18, 19, 20\n21, 22, 23\n24, 25, 26\n27, 28, 29\n</code></pre> <p> Try example</p>"},{"location":"mixed_language/","title":"Mixed-language programming","text":""},{"location":"oop/","title":"Object-oriented programming","text":"<p>In procedural programming, data and subroutines are treated separately. Subroutines operate on provided data structures and variables. In object-oriented programming data and subroutines are combined into objects. Objects in numerical computing can be different matrix types, particles, vectors or solvers. The major benefits are that the actual data structures used in the implementation of an object can be hidden from the user of the object, enabling the developer of an object to improve the implementation without affecting users of the objects (encapsulation). Another important feature of object-oriented programming is the ability to inherit and extend the functionality of objects (inheritance). This enables users of objects and developers to extend and modify the functionality of existing objects, relying on the functionality of the parent object.</p> <p>The functionality and data structures of objects are defined in classes in most programming object-oriented languages. Classes can be seen as templates or blueprints for objects. When an object is to be created the class is used as the template to construct the new object. Created objects are also called instances of a class.</p> <ul> <li>Normal programs can be seen as several tasks/functions to perform. </li> <li>An object-oriented program can be seen as several interacting objects</li> <li>Objects can receive messages, process data, and send messages to other objects</li> <li>Objects hide data from view. Access through methods</li> <li>Object-oriented can be traced back to Simula 67</li> </ul> <p>Key features</p> <ul> <li>Dynamic dispatch (late binding)</li> <li>The actual method called is determined at runtime</li> <li>Enabled Polymorphism</li> <li>Polymorphism</li> <li>Several objects share characteristics</li> <li>Shape \u2013 Circle, Rectangle, Oval</li> <li>Encapsulation</li> <li>Combine data and function in a single entity</li> <li>Restricting access to actual data</li> <li>Inheritance</li> <li>Reuse code of an existing object/classes</li> <li>Inherit attributes from existing classes</li> </ul>"},{"location":"oop/#classes-in-c","title":"Classes in C++","text":"<p>C++ introduces the concept of a class. A class can be seen as a combination of data and functions/methods into a single entity, the class. As a language concept, it is very close to the basic struct data type in C++ in which data fields can be combined into a single user-defined data type. The class concept extends the struct data type with access methods and access attributes. The idea is that class attributes should only be accessed using methods, to hide the underlying implementation.</p> <p>An example of a class could be a vector with x and y components. We can add methods for translating the vector, getting and setting the vector components and printing the component values. The first step is to define the class and the attribute variables for the coordinates, m_x and m_y, as shown in the following code:</p> <pre><code>class Vector {\n    float m_x{};\n    float m_y{};\n};\n</code></pre> <p>The class declaration can be seen as a template of an object. To create a Point object we declare it just like any other variable in C++ by specifying the class Point as the type and giving a name of the object as shown in the code below:</p> <pre><code>Vector v;\n</code></pre> <p>However if we access the member variables, m_x and m_y</p> <pre><code>std::cout &lt;&lt; v.m_x &lt;&lt; \", \" &lt;&lt; v.m_y &lt;&lt; \"\\n\";\n</code></pre> <p>will produce the following error</p> <pre><code>cannot access private member Vector::m_x\n  member declared at example.cpp:4:11\n    std::cout &lt;&lt; v.m_x &lt;&lt; \"\\n\"; \n</code></pre> <p> Try example</p> <p>which is expected behavior. By default, all attributes of a class are private, which means that we cannot access the Vector member functions. To access these member attributes we need to add access methods. To do this we need to declare public access methods in our class. In addition to doing this, we also need to specify attributes to tell the compiler which parts of the class are private and public. This is done using the private: and public: class attributes. The modified class then becomes:</p> <pre><code>#include &lt;iostream&gt;\n\nclass Vector {\nprivate:\n    float m_x{};\n    float m_y{};\npublic:\n    void setX(float x) \n    { \n        m_x = x; \n    };\n\n    void setY(float y)\n    { \n        m_y = y; \n    };\n\n    void set(float x, float y)\n    {\n        m_x = x;\n        m_y = y;\n    }\n\n    float x() const\n    { \n        return m_x; \n    };\n\n    float y() const\n    { \n        return m_y; \n    };\n\n    void print() const\n    {\n        std::cout &lt;&lt; \"(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\\n\";\n    }\n\n};\n\nint main()\n{\n    Vector v;\n    v.set(1.0, -2.0);\n\n    std::cout &lt;&lt; p.x() &lt;&lt; \", \" &lt;&lt; p.y() &lt;&lt; \"\\n\";\n\n    p.print();\n}\n</code></pre> <p>In this code, we have added 6 methods 3 for assigning the m_x and m_y attributes and 2 methods for returning the values of the attributes. By using access methods like in this way, the user of the object v doesn't need to know how the actual storage of the components is implemented. They could be stored in a remote database, but the way of assigning and retrieving the values stays the same. </p> <p> Try example</p>"},{"location":"oop/#class-initialisation","title":"Class initialisation","text":"<p>When declaring class variables it is important that the default state of the variables are initialised. This can be done in several ways. The easiest way is to assign default values in the declaration of class variable. In the Vector class this was done using the {}-brackets:</p> <pre><code>float m_x{};\nfloat m_y{};\n</code></pre> <p>Using empty brackets will initialise the variable to its default value most of the time 0 or 0.0. It is also possible to initial values by using a class constructor. A class constructor is a special function that is called when a new object is created. This method can be used to initialise variables and do more complex initialisation operations that can't be handled by default initialisation procedures. In the following code we have added a constructor that initialises the m_x and m_y class variables. Note that initialisation of class variables is done before the body of the function. It is possible to initialise the variables in the function body, but that is not as efficient.</p> <pre><code>#include &lt;iostream&gt;\n\nclass Vector {\nprivate:\n    float m_x{};\n    float m_y{};\npublic:\n    Vector()\n        :m_x{-1.0}, m_y{-2.0}\n    {\n        std::cout &lt;&lt; \"Vector() constructor called.\\n\";\n    }    \n    ...\n</code></pre> <p>If we create a Vector instance with the following code:</p> <pre><code>Vector v;\n\nv.print();\n</code></pre> <p>will produce the following output:</p> <pre><code>Vector() constructor called.\n(-1, -2)\n</code></pre> <p>We can clearly see that the constructor is called when the Vector object is created. We can also see that the member variables have changed their default values to -1 and -2.</p>"},{"location":"oop/#constructor-with-arguments","title":"Constructor with arguments","text":"<p>For our Vector class it would also be nice to be able to create an object in a single statement where we give it the vector components in the declaration. This can be done by modifying our existing class constructor:</p> <pre><code>class Vector {\nprivate:\n    float m_x{};\n    float m_y{};\npublic:\n    Vector(float x=0.0, float y=0.0)\n    :m_x{x}, m_y{y}\n    {}\n    ...\n</code></pre> <p>By using default arguments to the constructor it is still possible to declare a Vector object without any arguments. A vector can now be created using the following code:</p> <pre><code>Vector v{1.0, -2.0};\n</code></pre> <p>If no constructor is declared, C++ will automatically generate default constructors for your class. For simple classes this is often enough, for more complex classes these constructors need to be provided by the classes. The following example shows when the different constructors are used:</p> <pre><code>Vector v0;            // Default constructor\nVector v1{1.0, -2.0}; // Default or constructor with arguments.\nVector v2 = v1;       // Copy constructor\nv0 = v2;              // Assignment operator\n</code></pre>"},{"location":"oop/#the-copy-constructor","title":"The copy constructor","text":"<p>A special constructor is called when initialising a new object by assigning an existing object. It looks like the code below:</p> <pre><code>Vector v2 = v1;\n</code></pre> <p>In the constructor we need to copy the values of the v1 object into the new object v2. Adding a copy constructor to the Vector class is shown below:</p> <pre><code>Vector(const Vector&amp; other)\n: m_x{other.m_x}, m_y{other.m_y}\n{}\n</code></pre> <p>In the constructor we initialise the local class variables with the other objects corresponding variables. Please note that the incoming other object is declared as const and passed by reference. This avoids copying of the object and accidental modification.</p>"},{"location":"oop/#the-assignment-operator","title":"The assignment operator","text":"<p>A similar operation to the copy constructor is the assignment operator. This operator is called when one object is assigned from a another object. As shown in the followng code:</p> <pre><code>v0 = v2; // Assignment operator\n</code></pre> <p>To implement an assignment operator we add the following code to our class:</p> <pre><code>Vector&amp; operator=(const Vector&amp; other)\n{\n    m_x = other.m_x;\n    m_y = other.m_y;\n    return *this;\n}\n</code></pre> <p>The difference from the copy constructor is that the assignment is done in the function body and we need to return a pointer to our own object (*this).</p>"},{"location":"oop/#implementing-vector-operations","title":"Implementing vector operations","text":"<p>To perform vector operations such as addition, subtraction, and scalar multiplication, we can add member functions to our Vector class. In C++, all operators in the language can be implemented as special methods added to our class implementation. The + operator is implemented using the special operator+(...) method. An example implementation of this operator is shown in the class below:</p> <pre><code>Vector operator+(const Vector&amp; other) const {\n    return Vector(m_x + other.m_x, m_y + other.m_y);\n}\n</code></pre> <p>We can now perform operations such as:</p> <pre><code>Vector v1{1.0, 1.0};\nVector v2{2.0, 2.0};\nVector v3 = v1 + v2; // Copy constructor + operator+(...) \n</code></pre> <p>We can now add other operator methods in the same way. Functions for calculating scalar and cross products can be added as additional class methods.</p> <pre><code>float Vector::dot(const Vector&amp; other) const {\n    return m_x * other.m_x + m_y * other.m_y;\n}\n\nfloat Vector::cross(const Vector&amp; other) const {\n    return m_x * other.m_y - m_y * other.m_x;\n}\n</code></pre> <p>Cross products and scalar product can now be calculated as shown in the following code:</p> <pre><code>Vector v5{ 1.0, 0.0 };\nVector v6{ 0.0, 1.0 };\n\ncout &lt;&lt; \"v5.dot(v6) = \" &lt;&lt; v5.dot(v6) &lt;&lt; endl;\ncout &lt;&lt; \"v5.cross(v6) = \" &lt;&lt; v5.cross(v6) &lt;&lt; endl;\n</code></pre> <p>Which gives the following output:</p> <pre><code>v5.dot(v6) = 0\nv5.cross(v6) = 1\n</code></pre> <p>We can also add a convenient length() method:</p> <pre><code>double Vector::length() const\n{\n    return std::sqrt(this-&gt;dot(*this));\n}\n</code></pre> <p>Calculating the length of a vector can now be done by calling the .length()-method.</p> <pre><code>cout &lt;&lt; \"v5.length() = \" &lt;&lt; v5.length() &lt;&lt; endl;\n</code></pre> <p>Which gives us the length of 1:</p> <pre><code>v5.length() = 1\n</code></pre> <p>Note</p> <p>The reason we add the const keyword in functions and argument lists is to indicate behavior to the compiler. The compiler can check for variable modifications and also generate more efficient code if it knows that a function will not modify the member variables of a class. </p>"},{"location":"oop/#inheritance","title":"Inheritance","text":"<p>One of the key concepts of object-oriented programming is inheritance. Using this concept, we can define new classes that inherit behavior and attributes from existing classes. This can be beneficial, for example, if we were designing a graphics library. In our library, we want to be able to draw shapes on the screen. Many of these shapes share attributes such as position, fill color, and line color. There could also be methods for moving and querying the area of a shape.</p>"},{"location":"oop/#defining-a-base-class-shape","title":"Defining a base class Shape","text":"<p>To define our classes, we start by defining a base class, in this case, it could be Shape. For our shape, we need to be able to place the shape on the 2D screen, so attributes are needed for position, fill color, line color, and a display name. The code below shows an example of how a base class for our class library could look:</p> <p><pre><code>class Shape {\nprivate:\n    double m_x{};\n    double m_y{};\n    double m_fillColor[4]{ 1.0, 0.0, 0.0, 1.0 };\n    double m_lineColor[4]{ 0.0, 0.0, 0.0, 1.0 };\n    std::string m_name{};\npublic:\n    Shape();\n    Shape(double x, double y);\n\n    void setPosition(double x, double y);\n    double x() const;\n    double y() const;\n\n    void setFillColor(double r, double g, double b, double a);\n    void setLineColor(double r, double g, double b, double a);\n\n    void getFillColor(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const;\n    void getLineColor(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const;\n\n    void setName(const std::string&amp; name);\n    std::string name() const;\n\n    virtual void print() const;\n    virtual double area() const;\n    virtual void draw() const;\n};\n</code></pre> We also need some common methods for our new Shape class such as .draw(), .print() and .area(). These methods should be implemented by other inherited classes and only skeleton implementations are provided by Shape. Methods that are supposed to be overridden by inherited classes should be marked with virtual. This also makes it possible for the correct methods to be called when working with a collection of different types of shapes. The following code is added to the class:</p> <pre><code>public:\n    ...\n    virtual void print() const;\n    virtual double area() const;\n    virtual void draw() const;\n    ...\n</code></pre> <pre><code>public:\n    ...\n    virtual void print() const;\n    virtual double area() const;\n    virtual void draw() const;\n    ...\n</code></pre>"},{"location":"oop/#implementing-a-circle-shape","title":"Implementing a Circle shape.","text":"<p>To implement a Circle shape we create a new class definition inheriting from the Shape class.</p> <p><pre><code>class Circle : public Shape {\nprivate:\n    double m_radius{1.0};\npublic:\n    Circle(double x = 1.0, double y = 1.0, double radius = 1.0);\n\n    virtual void print() const override;\n    virtual double area() const override;\n    virtual void draw() const override;\n\n    double radius() const;\n    void setRadius(double radius);\n};\n</code></pre> Inheritance in a class is defined by adding : public Shape after the class name in the class definition. This tells the compiler that Circle inherits all of the public interface of the Shape class. This means that the Circle class can't access any of the private methods or attributes from the Shape, which is what we want. </p> <p>As we have an additional attribute, radius, we need to create suitable constructors. We also need to pass our constructor arguments to the Shape constructor and initialize the circle m_radius attribute. This is done just before the constructor code block. </p> <pre><code>Circle::Circle(double x, double y, double radius)\n    : Shape(x, y)\n    , m_radius{radius}\n{\n    this-&gt;setName(\"Circle\");\n}\n</code></pre> <p>To be able to draw a circle we need to override some of the methods of the Shape class such as print(), area() and draw(). </p> <p>The implementation of these classes are shown below:</p> <pre><code>void Circle::print() const\n{\n    Shape::print();\n    cout &lt;&lt; \"radius = \" &lt;&lt; m_radius &lt;&lt; endl;\n}\n\ndouble Circle::area() const\n{\n    double pi = 4 * std::atan(1);\n    return pow(m_radius, 2) * pi;\n}\n\nvoid Circle::draw() const\n{\n    Shape::draw();\n    // Draw a circle\n    cout &lt;&lt; \"Drawing a circle at: (\" &lt;&lt; x() &lt;&lt; \", \" &lt;&lt; y() &lt;&lt; \")\" &lt;&lt; endl;\n    cout &lt;&lt; \"Circle radius: \" &lt;&lt; m_radius &lt;&lt; endl;\n}\n</code></pre> <p>Notice that as we are overriding the print()-method of the Shape class. If we need any functionality of the base class we need to explicitely call this method from our overridden method, as shown in the print() and draw() method. For the area() method this is not required as we don't need any functionality from the Shape area() method.</p>"},{"location":"oop/#instantiating-classes","title":"Instantiating classes","text":"<p>To create an instance of a class we use the same syntax as for creating a variable. The following code creates a Circle object and calls the print() method.</p> <pre><code>Circle c{1.0, 1.0, 2.0};\nc.print();\n</code></pre> <p>The output of the code will be:</p> <pre><code>Shape: Circle\nPosition: (1, 1)\nradius = 2\n</code></pre> <p>Instances created in this way are allocated on the stack. The stack is a memory area that is automatically managed by the compiler. The stack is used for local variables and function calls. The stack is fast and efficient but has a limited size.</p> <p>If more memory is required than the stack can provide, we need to allocate memory on the heap. The heap is a memory area that is managed by the operating system. Usually, the heap is slower than the stack but can hold much more data.</p> <p>If we want to allocate the object on the heap we can use the new keyword. The following code creates a Circle object on the heap and calls the print() method.</p> <pre><code>Circle* c = new Circle{1.0, 1.0, 2.0};\nc-&gt;print();\n</code></pre> <p>When we have allocated an object on the heap it has to be deallocated when it is no longer needed. This is done using the delete keyword. The following code shows how to deallocate the Circle object.</p> <pre><code>delete c;\n</code></pre> <p>The use of new and delete is discouraged in modern C++ programming. The reason for that is that it is easy to forget to deallocate memory, which can lead to memory leaks. Modern C++ programming uses smart pointers to manage memory allocation and deallocation. Smart pointers are a type of object that automatically deallocates memory when it is no longer needed. The following code shows how to create a Circle object using a smart pointer.</p> <pre><code>std::unique_ptr&lt;Circle&gt; c = std::make_unique&lt;Circle&gt;(1.0, 1.0, 2.0);\nc-&gt;print();\n</code></pre> <p>When the c object goes out of scope the smart pointer will automatically delete the object. </p> <p>The std::unique_ptr is a smart pointer that can only have one owner. This means that the object can't be copied or moved to another smart pointer. If we need to transfer ownership of the object we can use the std::move function. The following code shows how to transfer ownership of the c object to a new smart pointer.</p> <pre><code>std::unique_ptr&lt;Circle&gt; c2 = std::move(c);\n</code></pre> <p>After this code c will be empty and c2 will own the Circle object.</p> <p>If an object needs to be shared between multiple owners we can use the std::shared_ptr smart pointer. The std::shared_ptr keeps track of how many owners the object has and deallocates the object when the last owner is destroyed. The following code shows how to create a Circle object using a std::shared_ptr.</p> <pre><code>std::shared_ptr&lt;Circle&gt; c = std::make_shared&lt;Circle&gt;(1.0, 1.0, 2.0);\nc-&gt;print();\n</code></pre> <p>Using std::shared_ptr a pointer can easily be transferred to another owner. The following code shows how to transfer ownership of the c object to a new smart pointer.</p> <pre><code>std::shared_ptr&lt;Circle&gt; c2 = c;\n</code></pre> <p>After this code c and c2 will both own the Circle object. When the last owner is destroyed the object will be deallocated.</p> <p>To illustrate how we can creata simple class that prints out when it is created and destroyed.</p> <pre><code>class Test {\npublic:\n    Test() { std::printf(\"Test() constructor called.\\n\"); }\n    ~Test() { std::printf(\"~Test() destructor called.\\n\"); }\n};\n</code></pre> <p>To test object lifetimes we can use curly brackets to limit the scope of the object.</p> <pre><code>{\n    Test t;\n}\n</code></pre> <p>The output of the code will be:</p> <pre><code>Test() constructor called.\n~Test() destructor called.\n</code></pre> <p>Which is the expected output. The object is created when the scope is entered and destroyed when the scope is exited.</p> <p>Let's try the same thing using a smart pointer.</p> <pre><code>{\n    std::unique_ptr&lt;Test&gt; t = std::make_unique&lt;Test&gt;();\n}\n</code></pre> <p>The output of the code will be:</p> <pre><code>Test() constructor called.\n~Test() destructor called.\n</code></pre> <p>Which is the expected output. The object is created when the scope is entered and destroyed when the scope is exited.</p> <p>In the following example we illustrate how to use a shared pointer. In this example we create a shared pointer and transfer ownership to a new shared pointer inside another scope. </p> <pre><code>{\n    std::printf(\"Outer scope\\n\");\n    std::shared_ptr&lt;Test&gt; t = std::make_shared&lt;Test&gt;();\n    std::printf(\"t.use_count() = %d\\n\", t.use_count());\n    {\n        std::printf(\"Inner scope\\n\");\n        std::shared_ptr&lt;Test&gt; t2 = t;\n        std::printf(\"t.use_count() = %d\\n\", t.use_count());\n    }\n    std::printf(\"Outer scope\\n\");\n    std::printf(\"t.use_count() = %d\\n\", t.use_count());\n}\n</code></pre> <p>The output of the code will be:</p> <pre><code>Outer scope\nTest() constructor called.\nt.use_count() = 1\nInner scope\nt.use_count() = 2\nOuter scope\nt.use_count() = 1\n~Test() destructor called.\n</code></pre> <p> Try example</p>"},{"location":"oop/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism is the ability to operate on objects of different classes in the same way. This is achieved by using pointers to the base class. When a pointer to a base class is used to point to an object of a derived class, the derived class object can be treated as if it was a base class object. This is useful when working with collections of objects of different classes. The following code shows how to create a collection of Shape objects and call the print() method on each object.</p> <pre><code>vector&lt;std::shared_ptr&lt;Shape&gt;&gt; shapes;    \n\nshapes.push_back(std::make_shared&lt;Circle&gt;(1, 2, 3));\nshapes.push_back(std::make_shared&lt;Rectangle&gt;(4, 5, 6, 7));\n\nfor (const auto&amp; shape : shapes) \n{\n    shape-&gt;print();\n    shape-&gt;draw();\n    std::printf(\"Area: %f\\n\", shape-&gt;area());\n}\n</code></pre> <p>The output of the code will be:</p> <pre><code>Circle at (1.000000, 2.000000) with radius 3.000000\nDrawing Circle at (1.000000, 2.000000) with radius 3.000000\nArea: 28.274310\nRectangle at (4.000000, 5.000000) with width 6.000000 and height 7.000000\nDrawing Rectangle at (4.000000, 5.000000) with width 6.000000 and height 7.000000\nArea: 42.000000\n</code></pre> <p>Here we can see that the print(), draw() and area() methods of the Shape class are called for each object in the collection. The print() method of the Circle and Rectangle classes are called because they override the print() method of the Shape class. The same goes for the area() and draw() methods.</p> <p>.. note::</p> <pre><code>Polymorphism only works for pointers and references to objects. If we use objects directly, the methods of the base class will be called.\n</code></pre> <p> Try example</p>"},{"location":"oop/#abstract-classes","title":"Abstract classes","text":"<p>An abstract class is a class that can't be instantiated. Abstract classes are used to define a common interface for a group of classes. The Shape class is an example of an abstract class. Our current Shape class does not prevent it from being instatiated. To make the Shape class abstract we need to add a pure virtual method to the class. A pure virtual method is a method that has no implementation. Pure virtual functions are defined by assigning then 0. The following code shows how to make the Shape class abstract.</p> <pre><code>class Shape {\npublic:\n    ...\n    virtual void print() const = 0;\n    virtual double area() const = 0;\n    virtual void draw() const = 0;\n};\n</code></pre> <p>When a class has a pure virtual method it can't be instantiated. The following code will produce a compiler error.</p> <pre><code>Shape s; // Error: Can't instantiate an abstract class\nstd::unique_ptr&lt;Shape&gt; s = std::make_unique&lt;Shape&gt;(); // Error: Can't instantiate an abstract class\n</code></pre> <p>When deriving from a pure virtual class all pure virtual methods must be implemented. The following code shows how to implement the Shape class.</p> <pre><code>class Circle : public Shape {\npublic:\n    ...\n    virtual void print() const override;\n    virtual double area() const override;\n    virtual void draw() const override;\n};\n</code></pre>"},{"location":"oop/#composition","title":"Composition","text":"<p>Composition is a way to combine objects to create more complex objects. Composition is used when one object is part of another object. For example, a Car object can be composed of Wheel objects. The Wheel objects are part of the Car object. The following code shows how to create a Car class that is composed of Wheel objects.</p> <pre><code>class Wheel {\npublic:\n    Wheel() { std::printf(\"Wheel() constructor called.\\n\"); }\n    ~Wheel() { std::printf(\"~Wheel() destructor called.\\n\"); }\n};\n\nclass Car {\nprivate:\n    Wheel m_wheels[4];\npublic:\n    Car() { std::printf(\"Car() constructor called.\\n\"); }\n    ~Car() { std::printf(\"~Car() destructor called.\\n\"); }\n};\n</code></pre> <p>The following code shows how to create a Car object.</p> <pre><code>Car c;\n</code></pre> <p>The output of the code will be:</p> <pre><code>Wheel() constructor called.\nWheel() constructor called.\nWheel() constructor called.\nWheel() constructor called.\nCar() constructor called.\n</code></pre> <p>When the Car object is destroyed the Wheel objects are also destroyed. The following code shows how to destroy the Car object.</p> <pre><code>~Car() destructor called.\n~Wheel() destructor called.\n~Wheel() destructor called.\n~Wheel() destructor called.\n~Wheel() destructor called.\n</code></pre> <p> Try example</p>"},{"location":"oop/#header-and-source-files-for-classes","title":"Header and source files for classes","text":"<p>When working with classes it is common to split the class definition and implementation into two files. The class definition is placed in a header file with the extension .h or .hpp. The class implementation is placed in a source file with the extension .cpp. The following code shows how to split the Shape class into a header and source file.</p> <p>shape.h</p> <p>This file contains the class definition for the Shape class. Usually the header files don't contain the implementation of the methods, only the method signatures.</p> <pre><code>#ifndef SHAPE_H\n#define SHAPE_H\n\n#include &lt;string&gt;\n\nclass Shape {\nprivate:\n    double m_x{};\n    double m_y{};\n    double m_fillColor[4]{ 1.0, 0.0, 0.0, 1.0 };\n    double m_lineColor[4]{ 0.0, 0.0, 0.0, 1.0 };\n    std::string m_name{};\npublic:\n    Shape();\n    Shape(double x, double y);\n\n    void setPosition(double x, double y);\n    double x() const;\n    double y() const;\n\n    void setFillColor(double r, double g, double b, double a);\n    void setLineColor(double r, double g, double b, double a);\n\n    void getFillColor(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const;\n    void getLineColor(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const;\n\n    void setName(const std::string&amp; name);\n    std::string name() const;\n\n    virtual void print() const;\n    virtual double area() const;\n    virtual void draw() const;\n};\n\n#endif\n</code></pre> <p>The #ifndef, #define and #endif directives are used to prevent the header file from being included multiple times in the same file. This is called an include guard.</p> <p>shape.cpp</p> <p>This file contains the implementation of the Shape class. The first part of this file is the include directive for the shape.h file. This is done to make sure that the class definition is available when the implementation is compiled.</p> <pre><code>#include \"shape.h\"\n\nShape::Shape()\n{}\n\nShape::Shape(double x, double y)\n    : m_x{x}, m_y{y}\n{}\n\nvoid Shape::setPosition(double x, double y)\n{\n    m_x = x;\n    m_y = y;\n}\n\ndouble Shape::x() const\n{\n    return m_x;\n}\n\ndouble Shape::y() const\n{\n    return m_y;\n}\n\nvoid Shape::setFillColor(double r, double g, double b, double a)\n{\n    m_fillColor[0] = r;\n    m_fillColor[1] = g;\n    m_fillColor[2] = b;\n    m_fillColor[3] = a;\n}\n\nvoid Shape::setLineColor(double r, double g, double b, double a)\n{\n    m_lineColor[0] = r;\n    m_lineColor[1] = g;\n    m_lineColor[2] = b;\n    m_lineColor[3] = a;\n}\n\nvoid Shape::getFillColor(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const\n{\n    r = m_fillColor[0];\n    g = m_fillColor[1];\n    b = m_fillColor[2];\n    a = m_fillColor[3];\n}\n\nvoid Shape::getLineColor(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const\n{\n    r = m_lineColor[0];\n    g = m_lineColor[1];\n    b = m_lineColor[2];\n    a = m_lineColor[3];\n}\n\nvoid Shape::setName(const std::string&amp; name)\n{\n    m_name = name;\n}\n\nstd::string Shape::name() const\n{\n    return m_name;\n}\n\nvoid Shape::print() const\n{\n    std::printf(\"Shape: %s\\n\", m_name.c_str());\n    std::printf(\"Position: (%f, %f)\\n\", m_x, m_y);\n}\n\ndouble Shape::area() const\n{\n    return 0.0;\n}\n\nvoid Shape::draw() const\n{\n    std::printf(\"Drawing shape at: (%f, %f)\\n\", m_x, m_y);\n}\n</code></pre> <p>Using this method of splitting the class definition and implementation into two files makes it easier to manage large projects. It also makes it easier to reuse classes in other projects.</p>"},{"location":"oop/#alternatives-to-header-guards","title":"Alternatives to header guards","text":"<p>An alternative to using include guards is to use the #pragma once directive. The #pragma once directive tells the compiler to only include the file once. The following code shows how to use the #pragma once directive.</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n\nclass Shape {  \n    ...\n};\n</code></pre> <p>The #pragma once directive is supported by most modern compilers and is a more modern way of preventing multiple inclusions of the same file.</p>"},{"location":"oop/#object-oriented-analysis","title":"Object-oriented analysis","text":"<p>Object-oriented analysis is the process of defining the objects and their relationships in a system. The goal of object-oriented analysis is to identify the objects in a system and how they interact with each other. The following steps are used in object-oriented analysis:</p> <ol> <li>Identify the objects in the system</li> <li>Identify the relationships between the objects</li> <li>Identify the attributes of the objects</li> </ol> <p>The following example shows how to perform object-oriented analysis on a simple system.</p>"},{"location":"oop/#implementing-a-graphics-library","title":"Implementing a graphics library","text":"<p>As an example a simple graphics library will be implemented. The library will be able to draw shapes on the screen. The following objects are identified in the system:</p> <ul> <li>Shape - The base class for all shapes</li> <li>Circle - A circle shape</li> <li>Rectangle - A rectangle shape</li> <li>Line - A line shape</li> <li>Text - A text shape</li> <li>Composite - A composite shape</li> <li>Canvas - The canvas where the shapes are drawn</li> <li>Color - A color object</li> <li>Point - A point object</li> <li>Font - A font object</li> <li>Pen - A pen object</li> <li>Brush - A brush object</li> </ul> <p>The relationships between the objects are:</p> <ul> <li>Circle, Rectangle, Line, Text - Inherit from Shape</li> <li>Composite - Contains a list of Shape objects</li> <li>Canvas - Contains a list of Shape objects</li> </ul> <p>The attributes of the objects are:</p> <ul> <li>Shape - Position, fill color, line color</li> <li>Circle - Radius</li> <li>Rectangle - Width, height</li> <li>Line - Start point, end point</li> <li>Text - Text, font</li> <li>Composite - List of shapes</li> <li>Canvas - List of shapes</li> <li>Color - Red, green, blue, alpha</li> <li>Point - X, Y</li> <li>Font - Name, size</li> <li>Pen - Color, width</li> <li>Brush - Color</li> </ul> <p>We now have the base for our graphics library. The next step is to implement the classes and their relationships.</p>"},{"location":"oop/#object-oriented-design-of-a-particle-system","title":"Object-oriented design of a particle system","text":"<p>As an example a simple particle system will be implemented. The particle system will be able to simulate particles moving in a 2D space. The following objects are identified in the system:</p> <ul> <li>Vector - A 2D Vector class</li> <li>BaseParticle - The base class for all particles types</li> <li>Particle - A particle object</li> <li>ParticleSystem - The particle system that contains the particles</li> <li>Emitter - An emitter that emits particles</li> <li>Attractor - An attractor that attracts particles</li> <li>Repeller - A repeller that repels particles</li> <li>Boundary - A boundary that contains the particles</li> </ul> <p>The relationships between the objects are:</p> <ul> <li>BaseParticle - Inherit from Point</li> <li>Particle - Inherit from BaseParticle</li> <li>Particle and BaseParticle - Uses Vector for position, velocity, and acceleration</li> <li>ParticleSystem - Contains a list of Particle objects</li> <li>Emitter - Creates Particle objects</li> <li>Attractor - Attracts Particle objects</li> <li>Repeller - Repels Particle objects</li> <li>Boundary - Constrains Particle objects</li> </ul> <p>The attributes of the objects are:</p> <ul> <li>Point - X, Y</li> <li>BaseParticle - Position, velocity, acceleration, mass</li> <li>Particle - Lifetime, color</li> <li>ParticleSystem - List of particles</li> <li>Emitter - Position, emission rate</li> <li>Attractor - Position, strength</li> <li>Repeller - Position, strength</li> <li>Boundary - Position, width, height</li> </ul> <p>We now have the base for our particle system. The next step is to implement the classes and their relationships.</p> <p>The following code shows an example of how the classes could be implemented.</p> <pre><code>class Vector {\nprivate:\n    double m_x;\n    double m_y;\npublic:\n    Vector(double x, double y)\n        : m_x(x), m_y(y)\n    {}\n\n    double x() const { return m_x; }\n    double y() const { return m_y; }\n\n    void setX(double x) { m_x = x; }\n    void setY(double y) { m_y = y; }\n\n    void move(double dx, double dy) { m_x += dx; m_y += dy; }\n};\n\nclass BaseParticle {\nprivate:\n    Vector m_position;\n    Vector m_velocity;\n    Vector m_acceleration;\n    double m_mass;\npublic:\n    BaseParticle();\n    BaseParticle(const Vector&amp; position, const Vector&amp; velocity, const Vector&amp; acceleration, double mass);\n\n    void setPosition(const Vector&amp; position);\n    Vector position() const;\n\n    void setVelocity(const Vector&amp; velocity);\n    Vector velocity() const;\n\n    void setAcceleration(const Vector&amp; acceleration);\n    Vector acceleration() const;\n\n    void setMass(double mass);\n    double mass() const;\n\n    void move();\n    void applyForce(const Vector&amp; force);\n};\n\nclass Particle : public BaseParticle {\nprivate:\n    double m_lifetime;\n    Color m_color;\npublic:\n    Particle();\n    Particle(const Vector&amp; position, const Vector&amp; velocity, const Vector&amp; acceleration, double mass, double lifetime, const Color&amp; color);\n\n    void setLifetime(double lifetime);\n    double lifetime() const;\n\n    void setColor(const Color&amp; color);\n    Color color() const;\n};\n\nusing ParticlePtr = std::shared_ptr&lt;Particle&gt;;\n\nclass ParticleSystem {\nprivate:\n    std::vector&lt;ParticlePtr&gt; m_particles;\npublic:\n    ParticleSystem();\n\n    void addParticle(const ParticlePtr&amp; particle);\n    void removeParticle(const ParticlePtr&amp; particle);\n\n    void update();\n    void draw();\n};\n\nclass Emitter {\nprivate:\n    Vector m_position;\n    double m_emissionRate;\npublic:\n    Emitter(const Vector&amp; position, double emissionRate);\n\n    void setPosition(const Vector&amp; position);\n    Vector position() const;\n\n    void setEmissionRate(double emissionRate);\n    double emissionRate() const;\n\n    ParticlePtr emit();\n};\n\nclass Attractor {\nprivate:\n    Vector m_position;\n    double m_strength;\npublic:\n    Attractor(const Vector&amp; position, double strength);\n\n    void setPosition(const Vector&amp; position);\n    Vector position() const;\n\n    void setStrength(double strength);\n    double strength() const;\n\n    Vector force(const ParticlePtr&amp; particle) const;\n};\n\nclass Repeller {\nprivate:\n    Vector m_position;\n    double m_strength;\npublic:\n    Repeller(const Vector&amp; position, double strength);\n\n    void setPosition(const Vector&amp; position);\n    Vector position() const;\n\n    void setStrength(double strength);\n    double strength() const;\n\n    Vector force(const ParticlePtr&amp; particle) const;\n};\n\nclass Boundary {\nprivate:\n    Vector m_position;\n    double m_width;\n    double m_height;\npublic:\n    Boundary(const Vector&amp; position, double width, double height);\n\n    void setPosition(const Vector&amp; position);\n    Vector position() const;\n\n    void setWidth(double width);\n    double width() const;\n\n    void setHeight(double height);\n    double height() const;\n\n    void constrain(ParticlePtr&amp; particle);\n};\n</code></pre>"},{"location":"oop/#comments-on-object-oriented-analysis","title":"Comments on object-oriented analysis","text":"<p>Object-oriented analysis is a powerful tool for designing complex systems. By identifying the objects in a system and how they interact with each other, we can create a clear and concise design. Object-oriented analysis is used in many fields, including software development, engineering, and business. By using object-oriented analysis, we can create systems that are easy to understand, maintain, and extend.</p> <p>When using object-oriented analysis in computation science it is also important to consider the performance of the system. Object-oriented programming can introduce overhead in terms of memory and processing time. It is important to consider the trade-offs between performance and maintainability when designing a system.</p> <p>In the previous example the Particle class was instantiated in a std::vector and every particle allocated on the heap. This design can lead to performance issues when the number of particles is large. An alternative approach would be to implement a Particles class that implements a fixed-size array of particles. This would reduce the overhead of memory allocation and deallocation and improve performance. It is also possible to use a memory pool to allocate and deallocate particles more efficiently.</p>"}]}